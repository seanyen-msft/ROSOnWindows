{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"ROS for Windows People have always been fascinated by robots. Today advanced robots are changing our lives, both at work and at home. Warehouse robots have enabled next-day deliveries to online shoppers, and many pet owners rely on robotic vacuums to keep their floors clean. Industries as diverse as manufacturing, transportation, healthcare, and real estate are seeing benefits from robots. As robots have advanced, so have the development tools. Many developers leverage the Robot Operating System (ROS) , a set of libraries and tools which help you build complex robots. ROS is used in many cutting-edge robotic projects around the world. Microsoft is excited to announce the release of ROS 1 for Windows. This will bring the manageability and security of Windows 10 IoT Enterprise to the innovative ROS ecosystem. Windows has been a trusted part of robotic and industrial systems for decades. With ROS for Windows, developers will be able to use the familiar Visual Studio toolset along with rich AI and cloud features. We\u2019re looking forward to bringing the intelligent edge to robotics by exposing advanced features like hardware accelerated Windows Machine Learning, computer vision, Azure Cognitive Services, Azure IoT cloud services, and other Microsoft technologies to home, education, commercial, and industrial robots. Manufacturers want to make robots more aware of their surroundings, easier to program and safer to be around. Governments, manufacturers, and academics around the world are investing in the next generation of manufacturing, sometimes referred to as \u201cIndustry 4.0\u201d. ROS\u2122 is a Trademark of Open Robotics","title":"Home"},{"location":"index.html#ros-for-windows","text":"People have always been fascinated by robots. Today advanced robots are changing our lives, both at work and at home. Warehouse robots have enabled next-day deliveries to online shoppers, and many pet owners rely on robotic vacuums to keep their floors clean. Industries as diverse as manufacturing, transportation, healthcare, and real estate are seeing benefits from robots. As robots have advanced, so have the development tools. Many developers leverage the Robot Operating System (ROS) , a set of libraries and tools which help you build complex robots. ROS is used in many cutting-edge robotic projects around the world. Microsoft is excited to announce the release of ROS 1 for Windows. This will bring the manageability and security of Windows 10 IoT Enterprise to the innovative ROS ecosystem. Windows has been a trusted part of robotic and industrial systems for decades. With ROS for Windows, developers will be able to use the familiar Visual Studio toolset along with rich AI and cloud features. We\u2019re looking forward to bringing the intelligent edge to robotics by exposing advanced features like hardware accelerated Windows Machine Learning, computer vision, Azure Cognitive Services, Azure IoT cloud services, and other Microsoft technologies to home, education, commercial, and industrial robots. Manufacturers want to make robots more aware of their surroundings, easier to program and safer to be around. Governments, manufacturers, and academics around the world are investing in the next generation of manufacturing, sometimes referred to as \u201cIndustry 4.0\u201d. ROS\u2122 is a Trademark of Open Robotics","title":"ROS for Windows"},{"location":"WhatsNew.html","text":"What's New This page tracks changes to the ROS on Windows Documentation. May 2020 Simulation with Github Coming soon Continuous Deployment on Azure DevOps ROS::Time fixes We discovered a bug in low level time routines, which affects localization. Corrected and in testing. Gmapping By popular request, we're working on gmapping April 2020 Continuous Deployment on Github Added documentation for building Windows packages and publishing a chocolatey package as a github release. Continuous Simulation Lab Added a project which describes simulation during build, and tests which validate the build in simulation. March 2020 ROS Github Action From within Github, you can set up Continuous integration using a Github Action, brought to you by the Tooling Working Group of the ROS2 Technical Steering Committee, with contributions from Microsoft. MoveIt Updates MoveIt Tutorials have been updated to work on Windows. February 2020 Cross platform ROS node updates We have been adding notes to the porting cookbook based on customer feedback. Performance We've added a section on optimizing performance of Windows for Robotics scenarios. Windows 10 IoT Enterprise LTSC (Long Term Support Channel) is our recommended operating system for Robotics, as it offers the smallest footprint, and includes 10 years of support. January 2020 State of ROS on Windows ROS1 for Windows was announced generally available in May 2019. Since then it's use has continued to grow. Many companies are porting nodes to Windows. The Visual Studio Code extension has been incredibly well adopted within the community. New Look for Documents Documentation and Developer experience are a top priority. We're starting off by refreshing the look of docs; following up with turtorials on how to bring solutions up on Windows.","title":"What's New"},{"location":"WhatsNew.html#whats-new","text":"This page tracks changes to the ROS on Windows Documentation.","title":"What's New"},{"location":"WhatsNew.html#may-2020","text":"","title":"May 2020"},{"location":"WhatsNew.html#simulation-with-github","text":"Coming soon","title":"Simulation with Github"},{"location":"WhatsNew.html#continuous-deployment-on-azure-devops","text":"","title":"Continuous Deployment on Azure DevOps"},{"location":"WhatsNew.html#rostime-fixes","text":"We discovered a bug in low level time routines, which affects localization. Corrected and in testing.","title":"ROS::Time fixes"},{"location":"WhatsNew.html#gmapping","text":"By popular request, we're working on gmapping","title":"Gmapping"},{"location":"WhatsNew.html#april-2020","text":"","title":"April 2020"},{"location":"WhatsNew.html#continuous-deployment-on-github","text":"Added documentation for building Windows packages and publishing a chocolatey package as a github release.","title":"Continuous Deployment on Github"},{"location":"WhatsNew.html#continuous-simulation-lab","text":"Added a project which describes simulation during build, and tests which validate the build in simulation.","title":"Continuous Simulation Lab"},{"location":"WhatsNew.html#march-2020","text":"","title":"March 2020"},{"location":"WhatsNew.html#ros-github-action","text":"From within Github, you can set up Continuous integration using a Github Action, brought to you by the Tooling Working Group of the ROS2 Technical Steering Committee, with contributions from Microsoft.","title":"ROS Github Action"},{"location":"WhatsNew.html#moveit-updates","text":"MoveIt Tutorials have been updated to work on Windows.","title":"MoveIt Updates"},{"location":"WhatsNew.html#february-2020","text":"","title":"February 2020"},{"location":"WhatsNew.html#cross-platform-ros-node-updates","text":"We have been adding notes to the porting cookbook based on customer feedback.","title":"Cross platform ROS node updates"},{"location":"WhatsNew.html#performance","text":"We've added a section on optimizing performance of Windows for Robotics scenarios. Windows 10 IoT Enterprise LTSC (Long Term Support Channel) is our recommended operating system for Robotics, as it offers the smallest footprint, and includes 10 years of support.","title":"Performance"},{"location":"WhatsNew.html#january-2020","text":"","title":"January 2020"},{"location":"WhatsNew.html#state-of-ros-on-windows","text":"ROS1 for Windows was announced generally available in May 2019. Since then it's use has continued to grow. Many companies are porting nodes to Windows. The Visual Studio Code extension has been incredibly well adopted within the community.","title":"State of ROS on Windows"},{"location":"WhatsNew.html#new-look-for-documents","text":"Documentation and Developer experience are a top priority. We're starting off by refreshing the look of docs; following up with turtorials on how to bring solutions up on Windows.","title":"New Look for Documents"},{"location":"Advanced/Performance.html","text":"Performance This page covers guidelines for optimizing on Robot performance on Windows. Windows 10 IoT Enterprise LTSC Windows 10 IoT Enterprise is version of Windows intended for embedded applications. IoT isn't just about Lightbulbs and Thermostats (Windows 10 IoT Core is good for that), it's about network connected devices - including Robots. Windows 10 IoT Enterprise is a full desktop version of Windows, with a license to use on dedicated purpose devices. Windows 10 IoT Enterprise offers a Long Term Support Channel (also called LTSC), which allows you to lock a version with 10 years of support for a fixed up front cost. The LTSC version of Windows 10 IoT Enterprise offers an overall smaller on-disk and runtime footprint. You can try an evaluation of Windows 10 IoT Enterprise , then talk to a Windows 10 IoT Enterprise distributor to commercialize . Fair Process Scheduling By default, Windows prioritizes foreground applications. This can cause a 'unfair' scheduling of ROS nodes, which can impact throughput in a ROS composition. To make scheduling more fair, consider setting the priority control flag to prioritize background applications ( 0x18 ): reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\PriorityControl /v Win32PrioritySeparation /t REG_DWORD /d 0x18 /f Per process priority Adjusting the process scheduler can dramatically improve the flow of messages through a ROS composition. However, some ROS nodes might require a higher scheduling priority than others. To address this, there are two models you can use - If you have source access, you can tune the process scheduling using the SetPriorityClass API; otherwise you can use command line tool per process. Priority Class API Please refer to the documentation on SetPriorityClass . This API allows you to adjust the scheduling priority of a process from the ROS sources. NOTE: While tempting, it is best to avoid the REALTIME_PRIORITY_CLASS as this setting can be detemental to overall system performance. Command Line After you start a rosgraph with roslaunch , you can modify the priority of specific nodes using a PowerShell script. ( get-process ros_winml_node ). PriorityClass = 'AboveNormal' Integrating cross platform prioritization directly into ROSLaunch files. Wouldn't that be cool? Upvote if you think so. Disabling Services Using Windows 10 Desktop or Windows 10 IoT Enterprise comes with many services which are useful for general computing and enterprise scenarios. For Robotics, many services are not required. All services consume resources, so disabling unnessesary services would improve performance. During deployment, you should evaluate shich services are required by your scenario on a case by case basis. Please refer to this documentation for disabling Windows Services (guidance is applicable to Windows 10 IoT). High Resolution Time Windows Provides APIs for time using QueryPerformanceFrequency and QueryPerformanceCounter which returns the raw timer values. ROS time uses these APIs internally; however, you can use these high resolution timing outside of the ROS APIs. for more information, please refer to the High Resolution timestamp documentation . LARGE_INTEGER StartingTime , EndingTime , ElapsedMicroseconds ; LARGE_INTEGER Frequency ; QueryPerformanceFrequency ( & Frequency ); QueryPerformanceCounter ( & StartingTime ); // Activity to be timed QueryPerformanceCounter ( & EndingTime ); ElapsedMicroseconds . QuadPart = EndingTime . QuadPart - StartingTime . QuadPart ; // // We now have the elapsed number of ticks, along with the // number of ticks-per-second. We use these values // to convert to the number of elapsed microseconds. // To guard against loss-of-precision, we convert // to microseconds *before* dividing by ticks-per-second. // ElapsedMicroseconds . QuadPart *= 1000000 ; ElapsedMicroseconds . QuadPart /= Frequency . QuadPart ; Additionally, STL has been enlightened with QueryPerformanceCounter. For more information, please visit the <chrono> docs for steady_clock .","title":"Optimizing Performance"},{"location":"Advanced/Performance.html#performance","text":"This page covers guidelines for optimizing on Robot performance on Windows.","title":"Performance"},{"location":"Advanced/Performance.html#windows-10-iot-enterprise-ltsc","text":"Windows 10 IoT Enterprise is version of Windows intended for embedded applications. IoT isn't just about Lightbulbs and Thermostats (Windows 10 IoT Core is good for that), it's about network connected devices - including Robots. Windows 10 IoT Enterprise is a full desktop version of Windows, with a license to use on dedicated purpose devices. Windows 10 IoT Enterprise offers a Long Term Support Channel (also called LTSC), which allows you to lock a version with 10 years of support for a fixed up front cost. The LTSC version of Windows 10 IoT Enterprise offers an overall smaller on-disk and runtime footprint. You can try an evaluation of Windows 10 IoT Enterprise , then talk to a Windows 10 IoT Enterprise distributor to commercialize .","title":"Windows 10 IoT Enterprise LTSC"},{"location":"Advanced/Performance.html#fair-process-scheduling","text":"By default, Windows prioritizes foreground applications. This can cause a 'unfair' scheduling of ROS nodes, which can impact throughput in a ROS composition. To make scheduling more fair, consider setting the priority control flag to prioritize background applications ( 0x18 ): reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\PriorityControl /v Win32PrioritySeparation /t REG_DWORD /d 0x18 /f","title":"Fair Process Scheduling"},{"location":"Advanced/Performance.html#per-process-priority","text":"Adjusting the process scheduler can dramatically improve the flow of messages through a ROS composition. However, some ROS nodes might require a higher scheduling priority than others. To address this, there are two models you can use - If you have source access, you can tune the process scheduling using the SetPriorityClass API; otherwise you can use command line tool per process.","title":"Per process priority"},{"location":"Advanced/Performance.html#priority-class-api","text":"Please refer to the documentation on SetPriorityClass . This API allows you to adjust the scheduling priority of a process from the ROS sources. NOTE: While tempting, it is best to avoid the REALTIME_PRIORITY_CLASS as this setting can be detemental to overall system performance.","title":"Priority Class API"},{"location":"Advanced/Performance.html#command-line","text":"After you start a rosgraph with roslaunch , you can modify the priority of specific nodes using a PowerShell script. ( get-process ros_winml_node ). PriorityClass = 'AboveNormal'","title":"Command Line"},{"location":"Advanced/Performance.html#integrating-cross-platform-prioritization-directly-into-roslaunch-files","text":"Wouldn't that be cool? Upvote if you think so.","title":"Integrating cross platform prioritization directly into ROSLaunch files."},{"location":"Advanced/Performance.html#disabling-services","text":"Using Windows 10 Desktop or Windows 10 IoT Enterprise comes with many services which are useful for general computing and enterprise scenarios. For Robotics, many services are not required. All services consume resources, so disabling unnessesary services would improve performance. During deployment, you should evaluate shich services are required by your scenario on a case by case basis. Please refer to this documentation for disabling Windows Services (guidance is applicable to Windows 10 IoT).","title":"Disabling Services"},{"location":"Advanced/Performance.html#high-resolution-time","text":"Windows Provides APIs for time using QueryPerformanceFrequency and QueryPerformanceCounter which returns the raw timer values. ROS time uses these APIs internally; however, you can use these high resolution timing outside of the ROS APIs. for more information, please refer to the High Resolution timestamp documentation . LARGE_INTEGER StartingTime , EndingTime , ElapsedMicroseconds ; LARGE_INTEGER Frequency ; QueryPerformanceFrequency ( & Frequency ); QueryPerformanceCounter ( & StartingTime ); // Activity to be timed QueryPerformanceCounter ( & EndingTime ); ElapsedMicroseconds . QuadPart = EndingTime . QuadPart - StartingTime . QuadPart ; // // We now have the elapsed number of ticks, along with the // number of ticks-per-second. We use these values // to convert to the number of elapsed microseconds. // To guard against loss-of-precision, we convert // to microseconds *before* dividing by ticks-per-second. // ElapsedMicroseconds . QuadPart *= 1000000 ; ElapsedMicroseconds . QuadPart /= Frequency . QuadPart ; Additionally, STL has been enlightened with QueryPerformanceCounter. For more information, please visit the <chrono> docs for steady_clock .","title":"High Resolution Time"},{"location":"Build/buildfarm.html","text":"The BuildFarm for ROS on Windows The BuildFarm is a public service which is made of a set of tools and Azure DevOps pipelines to continuously build\\test\\deliver Open Robotics ROS for Windows developer community. Build Status Build Pipeline Build Status ros-catkin-build(melodic) ros-colon-build(noetic) ros-colon-build(crystal) ros-colon-build(dashing) ros-colon-build(eloquent) ros-colon-build(foxy) rosdep-au-packages Test Results Test Pipeline Test Status runtests.ros.melodic.desktop runtests.ros.melodic.ros_base ROS System Dependencies on Windows ROS target platforms defines a set of tools and packages which ROS packages depends on. Those tools and packages are also called ROS system dependencies, and they can be deployed by rosdep for any supported platforms. On Windows, Chocolatey is chosen as the default package manager for pre-built packages delivery, rosdep is extended to support Chocolatey and pip on Windows platform, and https://aka.ms/ros/public is created to host them for Windows developers. rosdep.yaml is also extended for Windows. Every ROS on Windows environment gets additional manifest files. For example, win-chocolatey.yaml defines what Chocolatey or pip packages to install when Windows developers uses rosdep to resolve dependencies. Azure DevOps Pipelines for System Dependencies Everytime an new package is identified to be onboarded for Windows. The pre-built binaries are generated offline and uploaded to rosdep-au-packages repository. It is an automatic packaging repository using Chocolatey Automatic Package Updater Module , and the deployment is automated in Azure DevOps. When a package is added or updated, rosdep-au-packages CI pipeline will be triggered, and it starts packaging and generating .nupkg files. After the packaging pipeline finishes, ROSDEP to ROSWIN Public Chocolatey Server pipeline will be triggered in turn and publishing those newly added\\updated packages to https://aka.ms/ros/public. ROS Build on Windows The Open Source Robotics Foundation (OSRF) maintains public buildfarm for the community. Package maintainers can make use of this public services to release ROS packages in sources or pre-built binaries on certain platforms. Likewise, the Buildfarm for ROS on Windows is an equivalent service to complement Windows developer community. Nightly Upstream Build Pipelines One goal of the buildfarm is to make sure every ROS packages built from the upstream (the latest) source code. It is important to catch any regressions as early as possible. ros-catkin-build/azure-pipelines.yml is the entry point for the build. It kicks off source installation on Azure DevOps and the binaries are packaged into Chocolatey packages. Pre-built Binaries Release Pipelines Whenever a nightly build finishes successfully, a deployment will start in turn, which publishes the Chocolatey packages to https://aka.ms/ros/public. The nightly builds will be firstly published as prerelease packages, and a prerelease package can be promoted to a release package when it mets quality criteria.","title":"The BuildFarm for ROS on Windows"},{"location":"Build/buildfarm.html#the-buildfarm-for-ros-on-windows","text":"The BuildFarm is a public service which is made of a set of tools and Azure DevOps pipelines to continuously build\\test\\deliver Open Robotics ROS for Windows developer community.","title":"The BuildFarm for ROS on Windows"},{"location":"Build/buildfarm.html#build-status","text":"Build Pipeline Build Status ros-catkin-build(melodic) ros-colon-build(noetic) ros-colon-build(crystal) ros-colon-build(dashing) ros-colon-build(eloquent) ros-colon-build(foxy) rosdep-au-packages","title":"Build Status"},{"location":"Build/buildfarm.html#test-results","text":"Test Pipeline Test Status runtests.ros.melodic.desktop runtests.ros.melodic.ros_base","title":"Test Results"},{"location":"Build/buildfarm.html#ros-system-dependencies-on-windows","text":"ROS target platforms defines a set of tools and packages which ROS packages depends on. Those tools and packages are also called ROS system dependencies, and they can be deployed by rosdep for any supported platforms. On Windows, Chocolatey is chosen as the default package manager for pre-built packages delivery, rosdep is extended to support Chocolatey and pip on Windows platform, and https://aka.ms/ros/public is created to host them for Windows developers. rosdep.yaml is also extended for Windows. Every ROS on Windows environment gets additional manifest files. For example, win-chocolatey.yaml defines what Chocolatey or pip packages to install when Windows developers uses rosdep to resolve dependencies.","title":"ROS System Dependencies on Windows"},{"location":"Build/buildfarm.html#azure-devops-pipelines-for-system-dependencies","text":"Everytime an new package is identified to be onboarded for Windows. The pre-built binaries are generated offline and uploaded to rosdep-au-packages repository. It is an automatic packaging repository using Chocolatey Automatic Package Updater Module , and the deployment is automated in Azure DevOps. When a package is added or updated, rosdep-au-packages CI pipeline will be triggered, and it starts packaging and generating .nupkg files. After the packaging pipeline finishes, ROSDEP to ROSWIN Public Chocolatey Server pipeline will be triggered in turn and publishing those newly added\\updated packages to https://aka.ms/ros/public.","title":"Azure DevOps Pipelines for System Dependencies"},{"location":"Build/buildfarm.html#ros-build-on-windows","text":"The Open Source Robotics Foundation (OSRF) maintains public buildfarm for the community. Package maintainers can make use of this public services to release ROS packages in sources or pre-built binaries on certain platforms. Likewise, the Buildfarm for ROS on Windows is an equivalent service to complement Windows developer community.","title":"ROS Build on Windows"},{"location":"Build/buildfarm.html#nightly-upstream-build-pipelines","text":"One goal of the buildfarm is to make sure every ROS packages built from the upstream (the latest) source code. It is important to catch any regressions as early as possible. ros-catkin-build/azure-pipelines.yml is the entry point for the build. It kicks off source installation on Azure DevOps and the binaries are packaged into Chocolatey packages.","title":"Nightly Upstream Build Pipelines"},{"location":"Build/buildfarm.html#pre-built-binaries-release-pipelines","text":"Whenever a nightly build finishes successfully, a deployment will start in turn, which publishes the Chocolatey packages to https://aka.ms/ros/public. The nightly builds will be firstly published as prerelease packages, and a prerelease package can be promoted to a release package when it mets quality criteria.","title":"Pre-built Binaries Release Pipelines"},{"location":"Build/fromsource.html","text":"Install ROS for Windows from source As an alternative to using Chocolatey, ROS for Windows can also be installed from source . ROS Environment Command Prompt When running ROS, open an elevated Command Prompt with the following setup: c : \\opt\\ros\\melodic\\x64\\setup.bat If you are building catkin projects, use the Visual Studio x64 command line shortcut that was created earlier to launch a Command Prompt or execute the following command in the current Command Prompt to make Visual Studio build tools discoverable for CMake: \"c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\" -arch=amd64 -host_arch=amd64","title":"Fromsource"},{"location":"Build/fromsource.html#install-ros-for-windows-from-source","text":"As an alternative to using Chocolatey, ROS for Windows can also be installed from source .","title":"Install ROS for Windows from source"},{"location":"Build/fromsource.html#ros-environment-command-prompt","text":"When running ROS, open an elevated Command Prompt with the following setup: c : \\opt\\ros\\melodic\\x64\\setup.bat If you are building catkin projects, use the Visual Studio x64 command line shortcut that was created earlier to launch a Command Prompt or execute the following command in the current Command Prompt to make Visual Studio build tools discoverable for CMake: \"c:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\Common7\\Tools\\VsDevCmd.bat\" -arch=amd64 -host_arch=amd64","title":"ROS Environment Command Prompt"},{"location":"Build/rosdeps_vcpkg.html","text":"[WIP] Vcpkg, ROS1 system dependencies, and Azure DevOps CI integration In ROS1, there are many open sources project required as a minimum to run ROS desktop stack. In the beginning, we either privately built the libraries by project-specific build instructions or looked for stock binaries if it just works. This approach works fine for the very initial ROS1 porting to manage the initial set of open sources libraries. However, we are also seeing problems with this method: * Build Instruction Management (How-to-build-xyz): Every new project could come with its owned way to build end-to-end. We should share the knowledge in a managible way. * Updatibility: Using stock binaries, it would be a bottleneck for us to upgrade its downstream projects (thinking about ABI changes or compatiblity), unless we know how to build them. * Latest Visual C++ toolchain support: Not every project keeps its build instructions or code up-to-dated for the latest Visual C++ toolchain. We want the binaries always come from the best of breed. To address those issues, we are looking for any leverages to solve them. Here Vcpkg comes. Vcpkg \"Vcpkg simplifies acquiring and building open source libraries on Windows.\" - Visual C++ Team Blog It comes with the following features: * Managing the how-to-build sauces of eight hundred and more open-source projects. And it is still growing! * Clear visibility on the dependencies relationship between projects. Now we can better manage what to update after an upstream project gets updated. * Everything is compiled against the same set of depedencies, so no more ABI hazards. Now let's take a look ROS1 system dependencies for Windows (as of today). ROS1 System Dependencies (Target: Melodic Windows 10) To evalute switching to Vcpkg, firstly we'd like to know anything missing from Vcpkg ports. After comparison, we see most of packages to exist on Vcpkg. Only few don't exist and need some more investigations: * libompl * log4cxx * libgraphviz * pkg-config Also, some projects are Python modules mixing C/C++ sources (e.g., pyside2), and Vcpkg currently doesn't manage this type of projects. References ROS1 Target Platforms Comparsion Table of ROS1 System Dependencies and vcpkg ports (snap at 2019/09/29 ) package version vcpkg port link note libflann 1.9.1 2019-04-07-1 (based on 1.9.1 ) flann zlib 1.2.11 1.2.11-5 zlib octomap 1.9.0 2017-03-11-7 (based on 1.8.0 ) octomap minor version libglew 2.1.0 2.1.0-6 glew ogre 1.10.11 1.12.1 ogre minor version libompl 1.2.2 1.4.2-2 ompl minor version assimp 4.0.1 5.0.0 assimp major version boost 1.66.0 1.71.0 boost minor version bullet3 2.87.0 2.88-1 bullet3 minor version bzip2 1.0.6 1.0.6-4 bzip2 console_bridge 0.4.0 0.4.3-1 console-bridge libccd 2.0.0 2.1-1 ccd minor version libcurl 7.58.0 7.66.0 curl minor version libfcl 0.5.0 0.5.0-6 fcl libjpeg-turbo 1.5.3 2.0.2 libjepg-turbo major version libopencv 3.4.1 4.1.1-1 opencv major version cppunit 1.12.1 1.14.0 cppunit minor version libpng 1.6.35 1.6.37-4 libpng eigen 3.3.4 3.3.7-3 eigen3 libqhull 2015.2.0 7.3.2-1 (based on 2019.1 ) qhull major version freeglut 3.0.0 3.0.0-7 freeglut log4cxx 0.10.0 N/A missing google-mock 1.8.0 2019-08-14-2 (based on 1.9.0 ) gtest minor version cairo 1.15.12 1.16.0-2 cairo minor version google-test 1.8.0 2019-08-14-2 (based on 1.9.0 ) gtest minor version gtk2 2.22.1 N/A missing gtk3 3.22.19 3.22.19-3 gtk poco 1.8.1 1.9.2-1 poco minor version pyqt5 5.10.1 N/A Python OpenNI unsure N/A missing OpenNI2 unsure 2.2.0.33-10 openni2 clapack 3.2.1 3.2.1-12 clapack gflags 2.2.1 2.2.2-1 gflags pyside2 5.10.1 N/A Python glog 0.3.5 0.4.0-2 glog minor version openblas 0.2.20 0.3.6-6 openblas minor version suitesparse unsure 5.4.0-3 suitesparse metis 5.1.0 5.1.0-5 metis sdl 1.2.15 1.2.15-8 sdl1 protobuf 3.6.1 3.9.1 protobuf minor version freeimage 3.17.0 3.18.0-7 freeimage minor version cppzmq 4.2.2 4.4.1 cppzmq minor version zeromq 4.2.5 2019-09-20 (based on 4.3.3 ) zeromq minor version dlfcn-win32 1.1.1 1.1.1-3 dlfcn-win32 libwebp 0.6.1 1.0.2-7 libwebp major version openjpeg 2.3.0 2.3.1-1 openjpeg tiff 4.0.9 4.0.10-7 tiff ilmbase 2.2.1 2.3.0 ilmbase minor version sdl_image 1.2.12 N/A missing jxrlib 1.1.0 1.1-8 jxrlib sip 4.19.8 N/A Python tinyxml 2.6.2 2.6.2-4 tinyxml libraw 0.19.0 201903-1 (based on 0.19.0 ) libraw tinyxml2 6.1.0 7.0.1-2 tinyxml2 major version liblzma 5.2.4 5.2.4-2 liblzma urdfdom 1.0.0 1.0.3-1 urdfdom openexr 2.2.1 2.3.0-4 openexr minor version urdfdom_headers 1.0.0 1.0.4-1 urdfdom-headers lcms 2.8.0 2.9 lcms minor version yaml-cpp 0.5.3 0.6.2-3 yaml-cpp minor version jasper 2.0.14 2.0.16-2 jasper ceres 1.14.0 1.14.0-6 ceres qwt 6.1.3 6.1.3-8 qwt gazebo9 9.4.1 N/A missing libfltk 1.3.4 1.3.4-7 fltk libtbb-dev 2018.6.0 2019_U8-1 tbb libgraphviz 2.41.0 N/A missing lz4 1.8.1 1.9.2 lz4 minor version openssl 1.1.1 1.0.2s-1 openssl-windows minor version orocos_kdl 1.3.1 1.4-2 orocos-kdl minor version pkg-config 0.29.2 N/A missing qt5-sdk 5.10.1 5.12.5 qt5 minor version libtheora 1.1.1 1.2.0alpha1-20170719~vcpkg1-3 libtheora minor version libogg 1.3.3 1.3.4 libogg libpcl 1.8.1 1.9.1-9 pcl minor version libazure-iot-sdk-c 1.2.10 2019-08-20.1 (based on 1.3.4 ) azure-iot-sdk-c minor version libqglviewer 2.7.1 2.7.0-2 libqglviewer","title":"[WIP] Vcpkg, ROS1 system dependencies, and Azure DevOps CI integration"},{"location":"Build/rosdeps_vcpkg.html#wip-vcpkg-ros1-system-dependencies-and-azure-devops-ci-integration","text":"In ROS1, there are many open sources project required as a minimum to run ROS desktop stack. In the beginning, we either privately built the libraries by project-specific build instructions or looked for stock binaries if it just works. This approach works fine for the very initial ROS1 porting to manage the initial set of open sources libraries. However, we are also seeing problems with this method: * Build Instruction Management (How-to-build-xyz): Every new project could come with its owned way to build end-to-end. We should share the knowledge in a managible way. * Updatibility: Using stock binaries, it would be a bottleneck for us to upgrade its downstream projects (thinking about ABI changes or compatiblity), unless we know how to build them. * Latest Visual C++ toolchain support: Not every project keeps its build instructions or code up-to-dated for the latest Visual C++ toolchain. We want the binaries always come from the best of breed. To address those issues, we are looking for any leverages to solve them. Here Vcpkg comes.","title":"[WIP] Vcpkg, ROS1 system dependencies, and Azure DevOps CI integration"},{"location":"Build/rosdeps_vcpkg.html#vcpkg","text":"\"Vcpkg simplifies acquiring and building open source libraries on Windows.\" - Visual C++ Team Blog It comes with the following features: * Managing the how-to-build sauces of eight hundred and more open-source projects. And it is still growing! * Clear visibility on the dependencies relationship between projects. Now we can better manage what to update after an upstream project gets updated. * Everything is compiled against the same set of depedencies, so no more ABI hazards. Now let's take a look ROS1 system dependencies for Windows (as of today).","title":"Vcpkg"},{"location":"Build/rosdeps_vcpkg.html#ros1-system-dependencies-target-melodic-windows-10","text":"To evalute switching to Vcpkg, firstly we'd like to know anything missing from Vcpkg ports. After comparison, we see most of packages to exist on Vcpkg. Only few don't exist and need some more investigations: * libompl * log4cxx * libgraphviz * pkg-config Also, some projects are Python modules mixing C/C++ sources (e.g., pyside2), and Vcpkg currently doesn't manage this type of projects.","title":"ROS1 System Dependencies (Target: Melodic Windows 10)"},{"location":"Build/rosdeps_vcpkg.html#references","text":"ROS1 Target Platforms Comparsion Table of ROS1 System Dependencies and vcpkg ports (snap at 2019/09/29 ) package version vcpkg port link note libflann 1.9.1 2019-04-07-1 (based on 1.9.1 ) flann zlib 1.2.11 1.2.11-5 zlib octomap 1.9.0 2017-03-11-7 (based on 1.8.0 ) octomap minor version libglew 2.1.0 2.1.0-6 glew ogre 1.10.11 1.12.1 ogre minor version libompl 1.2.2 1.4.2-2 ompl minor version assimp 4.0.1 5.0.0 assimp major version boost 1.66.0 1.71.0 boost minor version bullet3 2.87.0 2.88-1 bullet3 minor version bzip2 1.0.6 1.0.6-4 bzip2 console_bridge 0.4.0 0.4.3-1 console-bridge libccd 2.0.0 2.1-1 ccd minor version libcurl 7.58.0 7.66.0 curl minor version libfcl 0.5.0 0.5.0-6 fcl libjpeg-turbo 1.5.3 2.0.2 libjepg-turbo major version libopencv 3.4.1 4.1.1-1 opencv major version cppunit 1.12.1 1.14.0 cppunit minor version libpng 1.6.35 1.6.37-4 libpng eigen 3.3.4 3.3.7-3 eigen3 libqhull 2015.2.0 7.3.2-1 (based on 2019.1 ) qhull major version freeglut 3.0.0 3.0.0-7 freeglut log4cxx 0.10.0 N/A missing google-mock 1.8.0 2019-08-14-2 (based on 1.9.0 ) gtest minor version cairo 1.15.12 1.16.0-2 cairo minor version google-test 1.8.0 2019-08-14-2 (based on 1.9.0 ) gtest minor version gtk2 2.22.1 N/A missing gtk3 3.22.19 3.22.19-3 gtk poco 1.8.1 1.9.2-1 poco minor version pyqt5 5.10.1 N/A Python OpenNI unsure N/A missing OpenNI2 unsure 2.2.0.33-10 openni2 clapack 3.2.1 3.2.1-12 clapack gflags 2.2.1 2.2.2-1 gflags pyside2 5.10.1 N/A Python glog 0.3.5 0.4.0-2 glog minor version openblas 0.2.20 0.3.6-6 openblas minor version suitesparse unsure 5.4.0-3 suitesparse metis 5.1.0 5.1.0-5 metis sdl 1.2.15 1.2.15-8 sdl1 protobuf 3.6.1 3.9.1 protobuf minor version freeimage 3.17.0 3.18.0-7 freeimage minor version cppzmq 4.2.2 4.4.1 cppzmq minor version zeromq 4.2.5 2019-09-20 (based on 4.3.3 ) zeromq minor version dlfcn-win32 1.1.1 1.1.1-3 dlfcn-win32 libwebp 0.6.1 1.0.2-7 libwebp major version openjpeg 2.3.0 2.3.1-1 openjpeg tiff 4.0.9 4.0.10-7 tiff ilmbase 2.2.1 2.3.0 ilmbase minor version sdl_image 1.2.12 N/A missing jxrlib 1.1.0 1.1-8 jxrlib sip 4.19.8 N/A Python tinyxml 2.6.2 2.6.2-4 tinyxml libraw 0.19.0 201903-1 (based on 0.19.0 ) libraw tinyxml2 6.1.0 7.0.1-2 tinyxml2 major version liblzma 5.2.4 5.2.4-2 liblzma urdfdom 1.0.0 1.0.3-1 urdfdom openexr 2.2.1 2.3.0-4 openexr minor version urdfdom_headers 1.0.0 1.0.4-1 urdfdom-headers lcms 2.8.0 2.9 lcms minor version yaml-cpp 0.5.3 0.6.2-3 yaml-cpp minor version jasper 2.0.14 2.0.16-2 jasper ceres 1.14.0 1.14.0-6 ceres qwt 6.1.3 6.1.3-8 qwt gazebo9 9.4.1 N/A missing libfltk 1.3.4 1.3.4-7 fltk libtbb-dev 2018.6.0 2019_U8-1 tbb libgraphviz 2.41.0 N/A missing lz4 1.8.1 1.9.2 lz4 minor version openssl 1.1.1 1.0.2s-1 openssl-windows minor version orocos_kdl 1.3.1 1.4-2 orocos-kdl minor version pkg-config 0.29.2 N/A missing qt5-sdk 5.10.1 5.12.5 qt5 minor version libtheora 1.1.1 1.2.0alpha1-20170719~vcpkg1-3 libtheora minor version libogg 1.3.3 1.3.4 libogg libpcl 1.8.1 1.9.1-9 pcl minor version libazure-iot-sdk-c 1.2.10 2019-08-20.1 (based on 1.3.4 ) azure-iot-sdk-c minor version libqglviewer 2.7.1 2.7.0-2 libqglviewer","title":"References"},{"location":"Build/source.html","text":"Installing from source (ROS for Windows) Install from source requires that you download and compile the source code on your own. This page is organized as the same way as ROS\\Installation\\Source . This page is still working in progress. Prerequisites Installing toolchains Follow the Prerequisites section from Setup.md to install Visual Studio Build Tool 2017, Cmake, and Chocolatey. Please note that ROS for Windows expects the 64-bit Python2.7 to be installed under C:\\opt\\python27amd64\\ . Installing bootstrap dependencies These tools are used to facilitate the download and management of ROS packages and their dependencies, among other things. Generic (pip): If you are using a non-Debian system you need to make sure that you have all build tools (compiler, CMake, etc.) installed. You can install all ROS Python tools via PIP: pip install -U rosdep rosinstall_generator wstool rosinstall curl --output requirements.txt -L https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/rosdistro_cache/catkin-requirements.txt pip install -U --no-deps --force-reinstall -r requirements.txt If there are errors with this or the rosdep step below, your system's version of pip may be out-of-date. Use your system's package management to update it, or use it to update itself: python -m pip install -U pip setuptools Initializing rosdep rosdep init curl --output 10-ms-iot.list -L https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/rosdep/sources.list.d/10-ms-iot.list copy 10-ms-iot.list c:\\etc\\ros\\rosdep\\sources.list.d rosdep update The 10-ms-iot.list points to the rosdep database of ROS for Windows and it will be evaulated before the default source list. Configure Chocolatey sources choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco source disable -n=chocolatey This will add roswin Chocolatey server as a source to discover libraries and tools. Also disable the default one to avoid any potential package naming conflicts. Installation Start by building the core ROS packages. Create a catkin Workspace In order to build the core packages, you will need a catkin workspace. Create one now: mkdir c:\\ros_catkin_ws cd c:\\ros_catkin_ws Next we will want to fetch the core packages so we can build them. We will use wstool for this. Select the wstool command for the particular variant you want to install: Desktop Install (recommended): ROS, rqt, rviz, and robot-generic libraries set ROSDISTRO_INDEX_URL = https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/index.yaml rosinstall_generator desktop --rosdistro melodic --deps --upstream-development > melodic-desktop.rosinstall wstool init src melodic-desktop.rosinstall ROS-Comm: (Bare Bones) ROS package, build, and communication libraries. No GUI tools. set ROSDISTRO_INDEX_URL = https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/index.yaml rosinstall_generator ros_comm --rosdistro melodic --deps --upstream-development > melodic-ros_comm.rosinstall wstool init src melodic-ros_comm.rosinstall This will add all of the catkin packages in the given variant and then fetch the sources into the ~/ros_catkin_ws/src directory. The command will take a few minutes to download all of the core ROS packages into the src folder. Resolving Dependencies Before you can build your catkin workspace you need to make sure that you have all the required dependencies. We use the rosdep tool for this: rosdep install --from-paths src --ignore-src --rosdistro melodic -r -y This will look at all of the packages in the src directory and find all of the dependencies they have. Then it will recursively install the dependencies. The --from-paths option indicates we want to install the dependencies for an entire directory of packages, in this case src. The --ignore-src option indicates to rosdep that it shouldn't try to install any ROS packages in the src folder from the package manager, we don't need it to since we are building them ourselves. The --rosdistro option is required because we don't have a ROS environment setup yet, so we have to indicate to rosdep what version of ROS we are building for. Finally, the -y option indicates to rosdep that we don't want to be bothered by too many prompts from the package manager. After a while (and maybe some prompts for your password) rosdep will finish installing system dependencies and you can continue. Building the catkin Workspace Once it has completed downloading the packages and resolving the dependencies you are ready to build the catkin packages. We will use the catkin_make_isolated command because there are both catkin and plain cmake packages in the base install, when developing on your catkin only workspaces you may choose to use catkin/commands/catkin_make which only works with catkin packages. Invoke catkin_make_isolated: set PATH = c:\\opt\\rosdeps\\x64\\bin; %PATH% copy \".\\src\\catkin\\bin\\catkin_make_isolated\" \".\\src\\catkin\\bin\\catkin_make_isolated.py\" python .\\src\\catkin\\bin\\catkin_make_isolated.py --use-nmake --install ^ - -install-space c:/opt/ros/melodic/x64 ^ - DCMAKE_BUILD_TYPE=Release ^ - DCMAKE_PREFIX_PATH=c:/opt/ros/melodic/x64;c:/opt/rosdeps/x64 The rosdep BIN path needs to be added to PATH so catkin can find the build tools (e.g. CMake). Now the packages should have been installed to c:/opt/ros/melodic/x64 or to wherever you specified with the --install-space argument. If you look in that directory you will see that a setup.bash file have been generated. To utilize the things installed there simply source that file like so: c : \\opt\\ros\\melodic\\x64\\setup.bat","title":"Source Installation"},{"location":"Build/source.html#installing-from-source-ros-for-windows","text":"Install from source requires that you download and compile the source code on your own. This page is organized as the same way as ROS\\Installation\\Source . This page is still working in progress.","title":"Installing from source (ROS for Windows)"},{"location":"Build/source.html#prerequisites","text":"","title":"Prerequisites"},{"location":"Build/source.html#installing-toolchains","text":"Follow the Prerequisites section from Setup.md to install Visual Studio Build Tool 2017, Cmake, and Chocolatey. Please note that ROS for Windows expects the 64-bit Python2.7 to be installed under C:\\opt\\python27amd64\\ .","title":"Installing toolchains"},{"location":"Build/source.html#installing-bootstrap-dependencies","text":"These tools are used to facilitate the download and management of ROS packages and their dependencies, among other things. Generic (pip): If you are using a non-Debian system you need to make sure that you have all build tools (compiler, CMake, etc.) installed. You can install all ROS Python tools via PIP: pip install -U rosdep rosinstall_generator wstool rosinstall curl --output requirements.txt -L https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/rosdistro_cache/catkin-requirements.txt pip install -U --no-deps --force-reinstall -r requirements.txt If there are errors with this or the rosdep step below, your system's version of pip may be out-of-date. Use your system's package management to update it, or use it to update itself: python -m pip install -U pip setuptools","title":"Installing bootstrap dependencies"},{"location":"Build/source.html#initializing-rosdep","text":"rosdep init curl --output 10-ms-iot.list -L https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/rosdep/sources.list.d/10-ms-iot.list copy 10-ms-iot.list c:\\etc\\ros\\rosdep\\sources.list.d rosdep update The 10-ms-iot.list points to the rosdep database of ROS for Windows and it will be evaulated before the default source list.","title":"Initializing rosdep"},{"location":"Build/source.html#configure-chocolatey-sources","text":"choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco source disable -n=chocolatey This will add roswin Chocolatey server as a source to discover libraries and tools. Also disable the default one to avoid any potential package naming conflicts.","title":"Configure Chocolatey sources"},{"location":"Build/source.html#installation","text":"Start by building the core ROS packages.","title":"Installation"},{"location":"Build/source.html#create-a-catkin-workspace","text":"In order to build the core packages, you will need a catkin workspace. Create one now: mkdir c:\\ros_catkin_ws cd c:\\ros_catkin_ws Next we will want to fetch the core packages so we can build them. We will use wstool for this. Select the wstool command for the particular variant you want to install: Desktop Install (recommended): ROS, rqt, rviz, and robot-generic libraries set ROSDISTRO_INDEX_URL = https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/index.yaml rosinstall_generator desktop --rosdistro melodic --deps --upstream-development > melodic-desktop.rosinstall wstool init src melodic-desktop.rosinstall ROS-Comm: (Bare Bones) ROS package, build, and communication libraries. No GUI tools. set ROSDISTRO_INDEX_URL = https://raw.githubusercontent.com/ms-iot/rosdistro-db/init_windows/index.yaml rosinstall_generator ros_comm --rosdistro melodic --deps --upstream-development > melodic-ros_comm.rosinstall wstool init src melodic-ros_comm.rosinstall This will add all of the catkin packages in the given variant and then fetch the sources into the ~/ros_catkin_ws/src directory. The command will take a few minutes to download all of the core ROS packages into the src folder.","title":"Create a catkin Workspace"},{"location":"Build/source.html#resolving-dependencies","text":"Before you can build your catkin workspace you need to make sure that you have all the required dependencies. We use the rosdep tool for this: rosdep install --from-paths src --ignore-src --rosdistro melodic -r -y This will look at all of the packages in the src directory and find all of the dependencies they have. Then it will recursively install the dependencies. The --from-paths option indicates we want to install the dependencies for an entire directory of packages, in this case src. The --ignore-src option indicates to rosdep that it shouldn't try to install any ROS packages in the src folder from the package manager, we don't need it to since we are building them ourselves. The --rosdistro option is required because we don't have a ROS environment setup yet, so we have to indicate to rosdep what version of ROS we are building for. Finally, the -y option indicates to rosdep that we don't want to be bothered by too many prompts from the package manager. After a while (and maybe some prompts for your password) rosdep will finish installing system dependencies and you can continue.","title":"Resolving Dependencies"},{"location":"Build/source.html#building-the-catkin-workspace","text":"Once it has completed downloading the packages and resolving the dependencies you are ready to build the catkin packages. We will use the catkin_make_isolated command because there are both catkin and plain cmake packages in the base install, when developing on your catkin only workspaces you may choose to use catkin/commands/catkin_make which only works with catkin packages. Invoke catkin_make_isolated: set PATH = c:\\opt\\rosdeps\\x64\\bin; %PATH% copy \".\\src\\catkin\\bin\\catkin_make_isolated\" \".\\src\\catkin\\bin\\catkin_make_isolated.py\" python .\\src\\catkin\\bin\\catkin_make_isolated.py --use-nmake --install ^ - -install-space c:/opt/ros/melodic/x64 ^ - DCMAKE_BUILD_TYPE=Release ^ - DCMAKE_PREFIX_PATH=c:/opt/ros/melodic/x64;c:/opt/rosdeps/x64 The rosdep BIN path needs to be added to PATH so catkin can find the build tools (e.g. CMake). Now the packages should have been installed to c:/opt/ros/melodic/x64 or to wherever you specified with the --install-space argument. If you look in that directory you will see that a setup.bash file have been generated. To utilize the things installed there simply source that file like so: c : \\opt\\ros\\melodic\\x64\\setup.bat","title":"Building the catkin Workspace"},{"location":"Build/status.html","text":"ROS on Windows Status This is the latest CI and release status of projects under ROS on Windows. Latest ROS on Windows Releases ROS Distribution Name Latest Build Version ROS Melodic Morenia ROS Noetic Ninjemys ROS 2 Dashing Diademata ROS 2 Eloquent Elusor ROS 2 Foxy Fitzroy Project CI Status Project Name CI Status azure_kinect_ros_driver ros_azure_iothub ros_msft_camera ros_msft_luis winml_tracker vscode-ros","title":"Build Status"},{"location":"Build/status.html#ros-on-windows-status","text":"This is the latest CI and release status of projects under ROS on Windows.","title":"ROS on Windows Status"},{"location":"Build/status.html#latest-ros-on-windows-releases","text":"ROS Distribution Name Latest Build Version ROS Melodic Morenia ROS Noetic Ninjemys ROS 2 Dashing Diademata ROS 2 Eloquent Elusor ROS 2 Foxy Fitzroy","title":"Latest ROS on Windows Releases"},{"location":"Build/status.html#project-ci-status","text":"Project Name CI Status azure_kinect_ros_driver ros_azure_iothub ros_msft_camera ros_msft_luis winml_tracker vscode-ros","title":"Project CI Status"},{"location":"GettingStarted/AddingVCPKG.html","text":"Adding a new port to VCPKG for use in a ROS Node vcpkg has thousands of recipies for many different cross platform libraries. If you find that a dependency is not part of vcpkg, this walkthrough will help you get started. Every package has its own idiosyncrasies, so this is only a general ROS specific guide. Please refer to the documentation Porting a C++ Dependency with vcpkg Before you begin, you'll want to fork vcpkg into your github account. Next, Fix up your the ROS environment to use your fork. cd c:\\opt\\vcpkg git remote add upstream https://github.com/microsoft/vcpkg git remote set-url origin https://github.com/ < your github > /vcpkg git fetch --all .\\bootstrap-vcpkg.bat Now we will add a port fpr the package. We will follow the process outlined on Packaging a Github Repo \u2197. Create a folder for the package you'd like to port, then add CONTROL and portfile.cmake files: CONTROL Source: < name> Version: < latest release version> Homepage: https://github.com/ < organization > / < project> Description: < Description from github> portfile.cmake include(vcpkg_common_functions) vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO < organization > / < project> REF < latest release version> SHA512 1 HEAD_REF master ) vcpkg_configure_cmake( SOURCE_PATH ${SOURCE_PATH} PREFER_NINJA ) vcpkg_install_cmake() file(INSTALL ${SOURCE_PATH}/COPYING DESTINATION ${CURRENT_PACKAGES_DIR}/share/ < project > RENAME copyright) Then build with vcpkg build <project>:x64-windows Which will error because of the SHA512 hash mismatch: File does not have expected hash: File path: [ C:/opt/vcpkg/downloads/temp/ < package > ] Expected hash: [ 1 ] Actual hash: [ 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c ] Which is replaced in the portfile above: SHA512 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c Then build again with vcpkg build <package>:x64-windows You may see errors message during the build. If so, you'll need to fix package and optionally provide a vcpkg patch file. Patching during vcpkg build We now need to change some code in order to make mavlink build correctly on Windows. Following vcpkg patching documentation , we will do the following. Seed the patch by adding the original unpacked sources (this won't be checked in): cd c:\\opt\\vcpkg\\buildtrees\\ < package> git init git add . git commit -m \"create patch\" Next, fix the sources and attempt to build. Once builds complete and testing succeeds, you can create a vcpkg patch: cd c:\\opt\\vcpkg\\buildtrees\\ < package > \\.... git diff > ..\\..\\..\\..\\ports\\ < port > \\ < path name > .patch And include it in the portfile: vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO < organization > / < project> REF < latest release version> SHA512 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c HEAD_REF master PATCHES \"generate-msgs.patch\" ) Committing a vcpkg Once you've successfully built and tested the vcpkg, you can submit the code and issue a pull request to the vcpkg repository.","title":"Porting a C++ Dependency"},{"location":"GettingStarted/AddingVCPKG.html#adding-a-new-port-to-vcpkg-for-use-in-a-ros-node","text":"vcpkg has thousands of recipies for many different cross platform libraries. If you find that a dependency is not part of vcpkg, this walkthrough will help you get started. Every package has its own idiosyncrasies, so this is only a general ROS specific guide. Please refer to the documentation","title":"Adding a new port to VCPKG for use in a ROS Node"},{"location":"GettingStarted/AddingVCPKG.html#porting-a-c-dependency-with-vcpkg","text":"Before you begin, you'll want to fork vcpkg into your github account. Next, Fix up your the ROS environment to use your fork. cd c:\\opt\\vcpkg git remote add upstream https://github.com/microsoft/vcpkg git remote set-url origin https://github.com/ < your github > /vcpkg git fetch --all .\\bootstrap-vcpkg.bat Now we will add a port fpr the package. We will follow the process outlined on Packaging a Github Repo \u2197. Create a folder for the package you'd like to port, then add CONTROL and portfile.cmake files: CONTROL Source: < name> Version: < latest release version> Homepage: https://github.com/ < organization > / < project> Description: < Description from github> portfile.cmake include(vcpkg_common_functions) vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO < organization > / < project> REF < latest release version> SHA512 1 HEAD_REF master ) vcpkg_configure_cmake( SOURCE_PATH ${SOURCE_PATH} PREFER_NINJA ) vcpkg_install_cmake() file(INSTALL ${SOURCE_PATH}/COPYING DESTINATION ${CURRENT_PACKAGES_DIR}/share/ < project > RENAME copyright) Then build with vcpkg build <project>:x64-windows Which will error because of the SHA512 hash mismatch: File does not have expected hash: File path: [ C:/opt/vcpkg/downloads/temp/ < package > ] Expected hash: [ 1 ] Actual hash: [ 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c ] Which is replaced in the portfile above: SHA512 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c Then build again with vcpkg build <package>:x64-windows You may see errors message during the build. If so, you'll need to fix package and optionally provide a vcpkg patch file.","title":"Porting a C++ Dependency with vcpkg"},{"location":"GettingStarted/AddingVCPKG.html#patching-during-vcpkg-build","text":"We now need to change some code in order to make mavlink build correctly on Windows. Following vcpkg patching documentation , we will do the following. Seed the patch by adding the original unpacked sources (this won't be checked in): cd c:\\opt\\vcpkg\\buildtrees\\ < package> git init git add . git commit -m \"create patch\" Next, fix the sources and attempt to build. Once builds complete and testing succeeds, you can create a vcpkg patch: cd c:\\opt\\vcpkg\\buildtrees\\ < package > \\.... git diff > ..\\..\\..\\..\\ports\\ < port > \\ < path name > .patch And include it in the portfile: vcpkg_from_github( OUT_SOURCE_PATH SOURCE_PATH REPO < organization > / < project> REF < latest release version> SHA512 02a61de205bd1dd116677cf4c530d7adb689442252aeafdc549d54531a62ab10e999062403ddb8aed3d89e4f248ad10c0998739b33004ec02e9914150854d47c HEAD_REF master PATCHES \"generate-msgs.patch\" )","title":"Patching during vcpkg build"},{"location":"GettingStarted/AddingVCPKG.html#committing-a-vcpkg","text":"Once you've successfully built and tested the vcpkg, you can submit the code and issue a pull request to the vcpkg repository.","title":"Committing a vcpkg"},{"location":"GettingStarted/AzureSetupCD.html","text":"Continuous Delivery Once your ROS package is built, it needs to be deployed to customers. ROS on Windows leverages the Chocolatey Package manager for Delivery. Chocolatey is an Open Source package manager for Windows, with a command line interface. Chocolatey packages are zip files which contain a descriptor - based on the Nuget Library manager. Once created, Packages are published to the Chocolatey package registry. Sign up to Publish packages Before you can publish packages, you need to acquire an API key from Chocolatey. To acquire an API key, you need to register for an account . Once you've registered for an account, you'll be assigned an API key, which you can assign to your local chocolatey install - and later as a Pipeline Secret. You can associate the API Key with your chocolatey command line tool to publish with the following command line: choco apikey --key xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx --source https://push.chocolatey.org/ Packaging collateral To build a chocolatey package, the following files and structure is recommended in your repository. The files will be described later. Repository Root package MyPackage.nuspec build.bat chocolateyInstall_template.ps1 tools rosdepInstall.bat Crafting a MyPackage.nuspec file A Chocolatey package includes a xml descriptor of the package. Create a file in the package folder named after your ROS package, with the code contents of template.nuspec . For example, if your ROS package is called MyCoolRobot, the file should be called MyCoolRobot.nuspec Modify the properties of the XML file based on your specific requirements. For example: <?xml version=\"1.0\"?> <package xmlns= \"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\" > <metadata> <id> MyCoolRobot </id> <version> 1.0.0 </version> <title> MyCoolRobot ROS package </title> <authors> Malcom Reynolds </authors> <licenseUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/License.txt </licenseUrl> <projectUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </projectUrl> <requireLicenseAcceptance> false </requireLicenseAcceptance> <description> MyCoolRobot for ROS on Windows. </description> <summary> MyCoolRobot packaged as a rosdep. </summary> <tags> ros MyCoolRobot </tags> <packageSourceUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </packageSourceUrl> <docsUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/Docs </docsUrl> </metadata> </package> Adding install scripts Create these files in the tools folder, and add the code contents of each. You can use these directly, or customize them for your project. Examples of customization include custom dependencies (like fetching and installing external Msi files). chocolateyInstall_template.ps1 tools rosdepInstall.bat Adding the build script In the root of the package folder, add a file with the code contents of build.bat . Replace <ros package> with the name of your nuspec from above. Testing the package In later states, the pipelines will generate a zip file containing the output of your ROS package. To simulate archive generation for testing, in your terminal window, change directory into the workspace containing your package, then build with install target. Install 7zip using Chocolatey (You only need to do this the first time you try to build a package). choco install 7zip Catkin catkin_make install -DCATKIN_BUILD_BINARY_PACKAGE=ON Colcon Coming Soon Package cd install 7z a -tzip ..\\src\\ < ros package > \\package\\tools\\drop.zip * cd ..\\src\\ < ros package > \\package build.bat If this command succeeds, you will have two nupkg files - one for pre-release in output-pre , and one release package in output . Install using the following command: choco install output-pre\\ < ros package > .1.0.0.nupkg Troubleshoot If the package fails to install correctly, the nupkg is a zip file. You can expand the zip file and examine the contents. Verify that names are spelled correctly and that the contents match. Once you find the error, you can recreate the package using build.bat, and reinstall using: choco install output-pre\\ < ros package > .1.0.0.nupkg --force NOTE: Chocolatey will remove the root folder of a zip based chocolatey package - which potentially includes other zip based packages. We recommend not uninstalling a chocolatey package for this reason. Manually Publish a chocolatey package choco push MyPackage.1.0.0.nupkg --source https://push.chocolatey.org/ Automatically generate chocolatey package during CI Once you've crafted your nuspec and tested the installation, you can generate the chocolatey package during CI and publish it as a release. Using AzureDevOps CI If a file called build.bat is detected in the package directory of the repository, the pipeline will execute it. The chocolatey package will be generated and an artifact will be published. The artifact can be downloaded by navigating to the build results and selecting the artifacts option under Related . The text for the option will be similar to 1 published; 1 consumed . Updating Chocolatey rosdep mappings Once your chocolatey package has been published, rosdep needs to be informed of how to find it. rosdep enumerates entries in package.xml , then uses a yaml mapping file to locate the package. To update that mapping file, please follow these steps: Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork: # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < package-name > : windows: chocolatey: depends: [ < chocolatey dependencies which aren't specified in the package.xml > ] packages: [ < chocolatey-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You may encounder a warning about missing packages. On Windows some packages were collapsed into their metapackage hosting package due to differences in dependency behavior on Windows.","title":"Continuous Delivery"},{"location":"GettingStarted/AzureSetupCD.html#continuous-delivery","text":"Once your ROS package is built, it needs to be deployed to customers. ROS on Windows leverages the Chocolatey Package manager for Delivery. Chocolatey is an Open Source package manager for Windows, with a command line interface. Chocolatey packages are zip files which contain a descriptor - based on the Nuget Library manager. Once created, Packages are published to the Chocolatey package registry.","title":"Continuous Delivery"},{"location":"GettingStarted/AzureSetupCD.html#sign-up-to-publish-packages","text":"Before you can publish packages, you need to acquire an API key from Chocolatey. To acquire an API key, you need to register for an account . Once you've registered for an account, you'll be assigned an API key, which you can assign to your local chocolatey install - and later as a Pipeline Secret. You can associate the API Key with your chocolatey command line tool to publish with the following command line: choco apikey --key xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx --source https://push.chocolatey.org/","title":"Sign up to Publish packages"},{"location":"GettingStarted/AzureSetupCD.html#packaging-collateral","text":"To build a chocolatey package, the following files and structure is recommended in your repository. The files will be described later. Repository Root package MyPackage.nuspec build.bat chocolateyInstall_template.ps1 tools rosdepInstall.bat","title":"Packaging collateral"},{"location":"GettingStarted/AzureSetupCD.html#crafting-a-mypackagenuspec-file","text":"A Chocolatey package includes a xml descriptor of the package. Create a file in the package folder named after your ROS package, with the code contents of template.nuspec . For example, if your ROS package is called MyCoolRobot, the file should be called MyCoolRobot.nuspec Modify the properties of the XML file based on your specific requirements. For example: <?xml version=\"1.0\"?> <package xmlns= \"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\" > <metadata> <id> MyCoolRobot </id> <version> 1.0.0 </version> <title> MyCoolRobot ROS package </title> <authors> Malcom Reynolds </authors> <licenseUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/License.txt </licenseUrl> <projectUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </projectUrl> <requireLicenseAcceptance> false </requireLicenseAcceptance> <description> MyCoolRobot for ROS on Windows. </description> <summary> MyCoolRobot packaged as a rosdep. </summary> <tags> ros MyCoolRobot </tags> <packageSourceUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </packageSourceUrl> <docsUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/Docs </docsUrl> </metadata> </package>","title":"Crafting a MyPackage.nuspec file"},{"location":"GettingStarted/AzureSetupCD.html#adding-install-scripts","text":"Create these files in the tools folder, and add the code contents of each. You can use these directly, or customize them for your project. Examples of customization include custom dependencies (like fetching and installing external Msi files). chocolateyInstall_template.ps1 tools rosdepInstall.bat","title":"Adding install scripts"},{"location":"GettingStarted/AzureSetupCD.html#adding-the-build-script","text":"In the root of the package folder, add a file with the code contents of build.bat . Replace <ros package> with the name of your nuspec from above.","title":"Adding the build script"},{"location":"GettingStarted/AzureSetupCD.html#testing-the-package","text":"In later states, the pipelines will generate a zip file containing the output of your ROS package. To simulate archive generation for testing, in your terminal window, change directory into the workspace containing your package, then build with install target. Install 7zip using Chocolatey (You only need to do this the first time you try to build a package). choco install 7zip Catkin catkin_make install -DCATKIN_BUILD_BINARY_PACKAGE=ON Colcon Coming Soon","title":"Testing the package"},{"location":"GettingStarted/AzureSetupCD.html#package","text":"cd install 7z a -tzip ..\\src\\ < ros package > \\package\\tools\\drop.zip * cd ..\\src\\ < ros package > \\package build.bat If this command succeeds, you will have two nupkg files - one for pre-release in output-pre , and one release package in output . Install using the following command: choco install output-pre\\ < ros package > .1.0.0.nupkg Troubleshoot If the package fails to install correctly, the nupkg is a zip file. You can expand the zip file and examine the contents. Verify that names are spelled correctly and that the contents match. Once you find the error, you can recreate the package using build.bat, and reinstall using: choco install output-pre\\ < ros package > .1.0.0.nupkg --force NOTE: Chocolatey will remove the root folder of a zip based chocolatey package - which potentially includes other zip based packages. We recommend not uninstalling a chocolatey package for this reason.","title":"Package"},{"location":"GettingStarted/AzureSetupCD.html#manually-publish-a-chocolatey-package","text":"choco push MyPackage.1.0.0.nupkg --source https://push.chocolatey.org/","title":"Manually Publish a chocolatey package"},{"location":"GettingStarted/AzureSetupCD.html#automatically-generate-chocolatey-package-during-ci","text":"Once you've crafted your nuspec and tested the installation, you can generate the chocolatey package during CI and publish it as a release.","title":"Automatically generate chocolatey package during CI"},{"location":"GettingStarted/AzureSetupCD.html#using-azuredevops-ci","text":"If a file called build.bat is detected in the package directory of the repository, the pipeline will execute it. The chocolatey package will be generated and an artifact will be published. The artifact can be downloaded by navigating to the build results and selecting the artifacts option under Related . The text for the option will be similar to 1 published; 1 consumed .","title":"Using AzureDevOps CI"},{"location":"GettingStarted/AzureSetupCD.html#updating-chocolatey-rosdep-mappings","text":"Once your chocolatey package has been published, rosdep needs to be informed of how to find it. rosdep enumerates entries in package.xml , then uses a yaml mapping file to locate the package. To update that mapping file, please follow these steps: Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork: # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < package-name > : windows: chocolatey: depends: [ < chocolatey dependencies which aren't specified in the package.xml > ] packages: [ < chocolatey-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You may encounder a warning about missing packages. On Windows some packages were collapsed into their metapackage hosting package due to differences in dependency behavior on Windows.","title":"Updating Chocolatey rosdep mappings"},{"location":"GettingStarted/AzureSetupCI.html","text":"Continuous Integration with Azure Pipelines This template helps you to set up a continuous integration (CI) build for your ROS repository with ROS. Use this template if you are not hosting your code in GitHub, if GitHub Actions are not sufficient or if you need to leverage specific Azure Pipelines features. Prerequisites \u2714\ufe0f Learn the basics of Getting Started with Azure Pipelines . \u2714\ufe0f Learn more about Azure Pipelines . Using the Pipeline Navigate to your Azure Pipelines project and create a new pipeline. Select the location of your project. If the project is hosted on GitHub, select the GitHub option and then select the repository. You may need to provide Azure Pipelines access permissions to the repository. Select the correct repository if it isn't already selected and click Approve and Install . When walking through the wizard, select starter pipeline and it will create a file of azure-pipelines.yml under the root of your ROS repository. Replace azure-pipelines.yml with the following content: resources : repositories : - repository : templates type : github name : ms-iot/rosonwindows_ci endpoint : <your github account> jobs : - template : build.yml@templates # Template reference parameters : rosdistro : melodic metapackage : desktop custom_version : '20200607.1.0' # Optional; default is `latest`. custom_test_target : 'run_tests' # Optional; default is `run_tests`. platforms : - linux - windows resources defines where to look for this common template. In this example, it defines a Github repository reference to ms-iot\\rosonwindows_ci and use an endpoint to access it. Replace endpoint to your Github account (or your GitHub service connection name). jobs\\template defines what template to be included. In this example, include build.yml@templates , which means to refer to the build.yml under ms-iot\\rosonwindows_ci GitHub repository. Under template , there are some parameters to customize your CI build: rosdistro and metapackage : You can use rosdistro for what ROS distro and metapackage for what the composition to check out for your CI build. In this example, it specifies to use melodic ROS distro and check out the ROS packages up to desktop . custom_version : You can use this to specify what's the metapackage version to checkout. This is currently supported only for Windows builds. custom_test_target : For projects which do not have run_tests as default test target, it can be set to a customized test target. platforms : You can use this to select what platforms to run CI builds. Currently linux and windows are supported values. Once the wizard finishes, your ROS package will build using the Azure Pipelines.","title":"Continuous Integration"},{"location":"GettingStarted/AzureSetupCI.html#continuous-integration-with-azure-pipelines","text":"This template helps you to set up a continuous integration (CI) build for your ROS repository with ROS. Use this template if you are not hosting your code in GitHub, if GitHub Actions are not sufficient or if you need to leverage specific Azure Pipelines features.","title":"Continuous Integration with Azure Pipelines"},{"location":"GettingStarted/AzureSetupCI.html#prerequisites","text":"\u2714\ufe0f Learn the basics of Getting Started with Azure Pipelines . \u2714\ufe0f Learn more about Azure Pipelines .","title":"Prerequisites"},{"location":"GettingStarted/AzureSetupCI.html#using-the-pipeline","text":"Navigate to your Azure Pipelines project and create a new pipeline. Select the location of your project. If the project is hosted on GitHub, select the GitHub option and then select the repository. You may need to provide Azure Pipelines access permissions to the repository. Select the correct repository if it isn't already selected and click Approve and Install . When walking through the wizard, select starter pipeline and it will create a file of azure-pipelines.yml under the root of your ROS repository. Replace azure-pipelines.yml with the following content: resources : repositories : - repository : templates type : github name : ms-iot/rosonwindows_ci endpoint : <your github account> jobs : - template : build.yml@templates # Template reference parameters : rosdistro : melodic metapackage : desktop custom_version : '20200607.1.0' # Optional; default is `latest`. custom_test_target : 'run_tests' # Optional; default is `run_tests`. platforms : - linux - windows resources defines where to look for this common template. In this example, it defines a Github repository reference to ms-iot\\rosonwindows_ci and use an endpoint to access it. Replace endpoint to your Github account (or your GitHub service connection name). jobs\\template defines what template to be included. In this example, include build.yml@templates , which means to refer to the build.yml under ms-iot\\rosonwindows_ci GitHub repository. Under template , there are some parameters to customize your CI build: rosdistro and metapackage : You can use rosdistro for what ROS distro and metapackage for what the composition to check out for your CI build. In this example, it specifies to use melodic ROS distro and check out the ROS packages up to desktop . custom_version : You can use this to specify what's the metapackage version to checkout. This is currently supported only for Windows builds. custom_test_target : For projects which do not have run_tests as default test target, it can be set to a customized test target. platforms : You can use this to select what platforms to run CI builds. Currently linux and windows are supported values. Once the wizard finishes, your ROS package will build using the Azure Pipelines.","title":"Using the Pipeline"},{"location":"GettingStarted/AzureSetupCS_Linux.html","text":"Continuous Simulation Lab with Azure Pipelines (Linux) Overview After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of Azure Pipelines and ROS on Azure with Linux VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on Azure Pipelines. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors . Objectives Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Linux virtual machine on Azure. Integrate a GitHub project with Azure Pipelines. Observe the simulation runs and test results on the pipeline. Prerequisites An Microsoft Azure account from https://portal.azure.com. An Azure DevOps account from https://dev.azure.com. A GitHub account from https://github.com. Exercise 1: Build And Run Autonomous Car Simulation Locally Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Ubuntu. Open a new shell. The below example assumes using bash . # Clone the github project git clone https://github.com/<your account>/ros_simulation_lab --recursive cd ros_simulation_lab # install required components sudo apt update rosdep update rosdep install --from-paths catkin_ws/src --ignore-src -r -y pip install circle-fit # build it cd catkin_ws catkin_make Run the autonomous car simulation. # source the ROS devel space. source ./devel/setup.bat # run the application roslaunch src/ar-tu-do/ros_ws/launch/gazebo.launch world: = racetrack mode_override: = 2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving. Exercise 2: Run ROSTest With Autonomous Car Simulation Locally End the previous exercise and run the following rostest file: # source the ROS devel space. source ./devel/setup.bat # run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with Azure Pipelines. Exercise 3: Provision Cloud CI Environment With Azure Pipelines Task 1: Prepare Permission For Azure DevOps Agent Pool This module guides you how to prepare permission for the agent pool. Take a note of the personal access token (PAT). Task 2: Deploy Virtual Machine and Register as Azure DevOps Build Agent This ROS on Azure with Linux VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Pipeline Provider : Select AzurePipelines to use Azure DevOps. Vsts Account : This is your Azure DevOps organization name. For example, this is the name of https://dev.azure.com/<name> . Vsts Personal Access Token : This is the PAT noted from the previous section. Vsts Pool Name : Leave it to Default to match the pool name in this exercise. Task 3: Integrate Your GitHub Projects With Azure Pipelines Fork ms-iot/ros_simulation_lab repository into your GitHub account. The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines-linux.yml . Now you should have a pipeline running (or ready to run). Task 4: Observe the Build Summary and Test Results Click on a finished build and you will see a summary like: Check the Related and there is one artifact published, where you can find details logs for this run. In this example, you can also find the bag files for further analysis. Check the Test and coverage and you can find details test results by following the pass rate hyperlink.","title":"Continuous Simulation (Linux)"},{"location":"GettingStarted/AzureSetupCS_Linux.html#continuous-simulation-lab-with-azure-pipelines-linux","text":"","title":"Continuous Simulation Lab with Azure Pipelines (Linux)"},{"location":"GettingStarted/AzureSetupCS_Linux.html#overview","text":"After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of Azure Pipelines and ROS on Azure with Linux VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on Azure Pipelines. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors .","title":"Overview"},{"location":"GettingStarted/AzureSetupCS_Linux.html#objectives","text":"Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Linux virtual machine on Azure. Integrate a GitHub project with Azure Pipelines. Observe the simulation runs and test results on the pipeline.","title":"Objectives"},{"location":"GettingStarted/AzureSetupCS_Linux.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com. An Azure DevOps account from https://dev.azure.com. A GitHub account from https://github.com.","title":"Prerequisites"},{"location":"GettingStarted/AzureSetupCS_Linux.html#exercise-1-build-and-run-autonomous-car-simulation-locally","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Ubuntu. Open a new shell. The below example assumes using bash . # Clone the github project git clone https://github.com/<your account>/ros_simulation_lab --recursive cd ros_simulation_lab # install required components sudo apt update rosdep update rosdep install --from-paths catkin_ws/src --ignore-src -r -y pip install circle-fit # build it cd catkin_ws catkin_make Run the autonomous car simulation. # source the ROS devel space. source ./devel/setup.bat # run the application roslaunch src/ar-tu-do/ros_ws/launch/gazebo.launch world: = racetrack mode_override: = 2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving.","title":"Exercise 1: Build And Run Autonomous Car Simulation Locally"},{"location":"GettingStarted/AzureSetupCS_Linux.html#exercise-2-run-rostest-with-autonomous-car-simulation-locally","text":"End the previous exercise and run the following rostest file: # source the ROS devel space. source ./devel/setup.bat # run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with Azure Pipelines.","title":"Exercise 2: Run ROSTest With Autonomous Car Simulation Locally"},{"location":"GettingStarted/AzureSetupCS_Linux.html#exercise-3-provision-cloud-ci-environment-with-azure-pipelines","text":"","title":"Exercise 3: Provision Cloud CI Environment With Azure Pipelines"},{"location":"GettingStarted/AzureSetupCS_Linux.html#task-1-prepare-permission-for-azure-devops-agent-pool","text":"This module guides you how to prepare permission for the agent pool. Take a note of the personal access token (PAT).","title":"Task 1: Prepare Permission For Azure DevOps Agent Pool"},{"location":"GettingStarted/AzureSetupCS_Linux.html#task-2-deploy-virtual-machine-and-register-as-azure-devops-build-agent","text":"This ROS on Azure with Linux VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Pipeline Provider : Select AzurePipelines to use Azure DevOps. Vsts Account : This is your Azure DevOps organization name. For example, this is the name of https://dev.azure.com/<name> . Vsts Personal Access Token : This is the PAT noted from the previous section. Vsts Pool Name : Leave it to Default to match the pool name in this exercise.","title":"Task 2: Deploy Virtual Machine and Register as Azure DevOps Build Agent"},{"location":"GettingStarted/AzureSetupCS_Linux.html#task-3-integrate-your-github-projects-with-azure-pipelines","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines-linux.yml . Now you should have a pipeline running (or ready to run).","title":"Task 3: Integrate Your GitHub Projects With Azure Pipelines"},{"location":"GettingStarted/AzureSetupCS_Linux.html#task-4-observe-the-build-summary-and-test-results","text":"Click on a finished build and you will see a summary like: Check the Related and there is one artifact published, where you can find details logs for this run. In this example, you can also find the bag files for further analysis. Check the Test and coverage and you can find details test results by following the pass rate hyperlink.","title":"Task 4: Observe the Build Summary and Test Results"},{"location":"GettingStarted/AzureSetupCS_Windows.html","text":"Continuous Simulation Lab with Azure Pipelines (Windows) Overview After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of Azure Pipelines and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on Azure Pipelines. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors . Objectives Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with Azure Pipelines. Observe the simulation runs and test results on the pipeline. Prerequisites An Microsoft Azure account from https://portal.azure.com. An Azure DevOps account from https://dev.azure.com. A GitHub account from https://github.com. Exercise 1: Build And Run Autonomous Car Simulation Locally Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Windows. Open the ROS command prompt, and run the following to build the project. : : Clone the github project git clone https://github.com/ < your account > /ros_simulation_lab --recursive cd ros_simulation_lab : : install required components vcpkg install sdl2:x64-windows pip install circle-fit : : build it cd catkin_ws catkin_make --use-ninja -DCMAKE_BUILD_TYPE=RELEASE Run the autonomous car simulation. : : source the ROS devel space. devel\\setup.bat : : run the application roslaunch src\\ar-tu-do\\ros_ws\\launch\\gazebo.launch world:=racetrack mode_override:=2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving. Exercise 2: Run ROSTest With Autonomous Car Simulation Locally End the previous exercise and run the following rostest file: : : source the ROS devel space. devel\\setup.bat : : run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with Azure Pipelines. Exercise 3: Provision Cloud CI Environment With Azure Pipelines Task 1: Prepare Permission For Azure DevOps Agent Pool This module guides you how to prepare permission for the agent pool. Take a note of the personal access token (PAT). Task 2: Deploy Virtual Machine and Register as Azure DevOps Build Agent This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select AzurePipelines to use Azure DevOps. Vsts Account : This is your Azure DevOps organization name. For example, this is the name of https://dev.azure.com/<name> . Vsts Personal Access Token : This is the PAT noted from the previous section. Vsts Pool Name : Leave it to Default to match the pool name in this exercise. Enable Autologon : Select True to run build agent in the interactive session. This is required for Gazebo. Task 3: Integrate Your GitHub Projects With Azure Pipelines Fork this repository into your GitHub account. The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines.yml . Now you should have a pipeline running (or ready to run). Task 4: Observe the Build Summary and Test Results Click on a finished build and you will see a summary like: Check the Related and there is one artifact published, where you can find details logs for this run. In this example, you can also find the bag files for further analysis. Check the Test and coverage and you can find details test results by following the pass rate hyperlink.","title":"Continuous Simulation (Windows)"},{"location":"GettingStarted/AzureSetupCS_Windows.html#continuous-simulation-lab-with-azure-pipelines-windows","text":"","title":"Continuous Simulation Lab with Azure Pipelines (Windows)"},{"location":"GettingStarted/AzureSetupCS_Windows.html#overview","text":"After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of Azure Pipelines and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on Azure Pipelines. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors .","title":"Overview"},{"location":"GettingStarted/AzureSetupCS_Windows.html#objectives","text":"Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with Azure Pipelines. Observe the simulation runs and test results on the pipeline.","title":"Objectives"},{"location":"GettingStarted/AzureSetupCS_Windows.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com. An Azure DevOps account from https://dev.azure.com. A GitHub account from https://github.com.","title":"Prerequisites"},{"location":"GettingStarted/AzureSetupCS_Windows.html#exercise-1-build-and-run-autonomous-car-simulation-locally","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Windows. Open the ROS command prompt, and run the following to build the project. : : Clone the github project git clone https://github.com/ < your account > /ros_simulation_lab --recursive cd ros_simulation_lab : : install required components vcpkg install sdl2:x64-windows pip install circle-fit : : build it cd catkin_ws catkin_make --use-ninja -DCMAKE_BUILD_TYPE=RELEASE Run the autonomous car simulation. : : source the ROS devel space. devel\\setup.bat : : run the application roslaunch src\\ar-tu-do\\ros_ws\\launch\\gazebo.launch world:=racetrack mode_override:=2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving.","title":"Exercise 1: Build And Run Autonomous Car Simulation Locally"},{"location":"GettingStarted/AzureSetupCS_Windows.html#exercise-2-run-rostest-with-autonomous-car-simulation-locally","text":"End the previous exercise and run the following rostest file: : : source the ROS devel space. devel\\setup.bat : : run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with Azure Pipelines.","title":"Exercise 2: Run ROSTest With Autonomous Car Simulation Locally"},{"location":"GettingStarted/AzureSetupCS_Windows.html#exercise-3-provision-cloud-ci-environment-with-azure-pipelines","text":"","title":"Exercise 3: Provision Cloud CI Environment With Azure Pipelines"},{"location":"GettingStarted/AzureSetupCS_Windows.html#task-1-prepare-permission-for-azure-devops-agent-pool","text":"This module guides you how to prepare permission for the agent pool. Take a note of the personal access token (PAT).","title":"Task 1: Prepare Permission For Azure DevOps Agent Pool"},{"location":"GettingStarted/AzureSetupCS_Windows.html#task-2-deploy-virtual-machine-and-register-as-azure-devops-build-agent","text":"This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select AzurePipelines to use Azure DevOps. Vsts Account : This is your Azure DevOps organization name. For example, this is the name of https://dev.azure.com/<name> . Vsts Personal Access Token : This is the PAT noted from the previous section. Vsts Pool Name : Leave it to Default to match the pool name in this exercise. Enable Autologon : Select True to run build agent in the interactive session. This is required for Gazebo.","title":"Task 2: Deploy Virtual Machine and Register as Azure DevOps Build Agent"},{"location":"GettingStarted/AzureSetupCS_Windows.html#task-3-integrate-your-github-projects-with-azure-pipelines","text":"Fork this repository into your GitHub account. The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines.yml . Now you should have a pipeline running (or ready to run).","title":"Task 3: Integrate Your GitHub Projects With Azure Pipelines"},{"location":"GettingStarted/AzureSetupCS_Windows.html#task-4-observe-the-build-summary-and-test-results","text":"Click on a finished build and you will see a summary like: Check the Related and there is one artifact published, where you can find details logs for this run. In this example, you can also find the bag files for further analysis. Check the Test and coverage and you can find details test results by following the pass rate hyperlink.","title":"Task 4: Observe the Build Summary and Test Results"},{"location":"GettingStarted/GithubSetupCD.html","text":"Continuous Delivery Once your ROS package is built, it needs to be deployed to customers. ROS on Windows leverages the Chocolatey Package manager for Delivery. Chocolatey is an Open Source package manager for Windows, with a command line interface. Chocolatey packages are zip files which contain a descriptor - based on the Nuget Library manager. Once created, Packages are published to the Chocolatey package registry. Sign up to Publish packages Before you can publish packages, you need to acquire an API key from Chocolatey. To acquire an API key, you need to register for an account . Once you've registered for an account, you'll be assigned an API key, which you can assign to your local chocolatey install - and later as a Pipeline Secret. You can associate the API Key with your chocolatey command line tool to publish with the following command line: choco apikey --key xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx --source https://push.chocolatey.org/ Packaging collateral To build a chocolatey package, the following files and structure is recommended in your repository. The files will be described later. Repository Root package MyPackage.nuspec build.bat chocolateyInstall_template.ps1 tools rosdepInstall.bat Crafting a MyPackage.nuspec file A Chocolatey package includes a xml descriptor of the package. Create a file in the package folder named after your ROS package, with the code contents of template.nuspec . For example, if your ROS package is called MyCoolRobot, the file should be called MyCoolRobot.nuspec Modify the properties of the XML file based on your specific requirements. For example: <?xml version=\"1.0\"?> <package xmlns= \"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\" > <metadata> <id> MyCoolRobot </id> <version> 1.0.0 </version> <title> MyCoolRobot ROS package </title> <authors> Malcom Reynolds </authors> <licenseUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/License.txt </licenseUrl> <projectUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </projectUrl> <requireLicenseAcceptance> false </requireLicenseAcceptance> <description> MyCoolRobot for ROS on Windows. </description> <summary> MyCoolRobot packaged as a rosdep. </summary> <tags> ros MyCoolRobot </tags> <packageSourceUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </packageSourceUrl> <docsUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/Docs </docsUrl> </metadata> </package> Adding install scripts Create these files in the tools folder, and add the code contents of each. You can use these directly, or customize them for your project. Examples of customization include custom dependencies (like fetching and installing external Msi files). chocolateyInstall_template.ps1 tools rosdepInstall.bat Adding the build script In the root of the package folder, add a file with the code contents of build.bat . Replace <ros package> with the name of your nuspec from above. Testing the package In later states, the pipelines will generate a zip file containing the output of your ROS package. To simulate archive generation for testing, in your terminal window, change directory into the workspace containing your package, then build with install target. Install 7zip using Chocolatey (You only need to do this the first time you try to build a package). choco install 7zip Catkin catkin_make install -DCATKIN_BUILD_BINARY_PACKAGE=ON Colcon Coming Soon Package cd install 7z a -tzip ..\\src\\ < ros package > \\package\\tools\\drop.zip * cd ..\\src\\ < ros package > \\package build.bat If this command succeeds, you will have two nupkg files - one for pre-release in output-pre , and one release package in output . Install using the following command: choco install output-pre\\ < ros package > .1.0.0.nupkg Troubleshoot If the package fails to install correctly, the nupkg is a zip file. You can expand the zip file and examine the contents. Verify that names are spelled correctly and that the contents match. Once you find the error, you can recreate the package using build.bat, and reinstall using: choco install output-pre\\ < ros package > .1.0.0.nupkg --force NOTE: Chocolatey will remove the root folder of a zip based chocolatey package - which potentially includes other zip based packages. We recommend not uninstalling a chocolatey package for this reason. Manually Publish a chocolatey package choco push MyPackage.1.0.0.nupkg --source https://push.chocolatey.org/ Automatically generate chocolatey package during CI Once you've crafted your nuspec and tested the installation, you can generate the chocolatey package during CI and publish it as a release. Now create the Github Action On github, select the Action tab. Create a new workflow In the new workflow, copy the contents of CD.yaml to the newly created workflow file. Replace <ros package> with the ROS package you are generating Replace <ros nuspec> with the name of the nuspec you from above Replace <ros version> with the version from your nuspec. Whenever you create a tag in the repo, it will trigger the deployment workflow, which will publish the nupkg as a github release. Updating Chocolatey rosdep mappings Once your chocolatey package has been published, rosdep needs to be informed of how to find it. rosdep enumerates entries in package.xml , then uses a yaml mapping file to locate the package. To update that mapping file, please follow these steps: Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork: # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < package-name > : windows: chocolatey: depends: [ < chocolatey dependencies which aren't specified in the package.xml > ] packages: [ < chocolatey-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You may encounder a warning about missing packages. On Windows some packages were collapsed into their metapackage hosting package due to differences in dependency behavior on Windows.","title":"Continuous Delivery"},{"location":"GettingStarted/GithubSetupCD.html#continuous-delivery","text":"Once your ROS package is built, it needs to be deployed to customers. ROS on Windows leverages the Chocolatey Package manager for Delivery. Chocolatey is an Open Source package manager for Windows, with a command line interface. Chocolatey packages are zip files which contain a descriptor - based on the Nuget Library manager. Once created, Packages are published to the Chocolatey package registry.","title":"Continuous Delivery"},{"location":"GettingStarted/GithubSetupCD.html#sign-up-to-publish-packages","text":"Before you can publish packages, you need to acquire an API key from Chocolatey. To acquire an API key, you need to register for an account . Once you've registered for an account, you'll be assigned an API key, which you can assign to your local chocolatey install - and later as a Pipeline Secret. You can associate the API Key with your chocolatey command line tool to publish with the following command line: choco apikey --key xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxxx --source https://push.chocolatey.org/","title":"Sign up to Publish packages"},{"location":"GettingStarted/GithubSetupCD.html#packaging-collateral","text":"To build a chocolatey package, the following files and structure is recommended in your repository. The files will be described later. Repository Root package MyPackage.nuspec build.bat chocolateyInstall_template.ps1 tools rosdepInstall.bat","title":"Packaging collateral"},{"location":"GettingStarted/GithubSetupCD.html#crafting-a-mypackagenuspec-file","text":"A Chocolatey package includes a xml descriptor of the package. Create a file in the package folder named after your ROS package, with the code contents of template.nuspec . For example, if your ROS package is called MyCoolRobot, the file should be called MyCoolRobot.nuspec Modify the properties of the XML file based on your specific requirements. For example: <?xml version=\"1.0\"?> <package xmlns= \"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\" > <metadata> <id> MyCoolRobot </id> <version> 1.0.0 </version> <title> MyCoolRobot ROS package </title> <authors> Malcom Reynolds </authors> <licenseUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/License.txt </licenseUrl> <projectUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </projectUrl> <requireLicenseAcceptance> false </requireLicenseAcceptance> <description> MyCoolRobot for ROS on Windows. </description> <summary> MyCoolRobot packaged as a rosdep. </summary> <tags> ros MyCoolRobot </tags> <packageSourceUrl> http://www.github.com/ContosoRobotics/MyCoolRobot </packageSourceUrl> <docsUrl> http://www.github.com/ContosoRobotics/MyCoolRobot/Docs </docsUrl> </metadata> </package>","title":"Crafting a MyPackage.nuspec file"},{"location":"GettingStarted/GithubSetupCD.html#adding-install-scripts","text":"Create these files in the tools folder, and add the code contents of each. You can use these directly, or customize them for your project. Examples of customization include custom dependencies (like fetching and installing external Msi files). chocolateyInstall_template.ps1 tools rosdepInstall.bat","title":"Adding install scripts"},{"location":"GettingStarted/GithubSetupCD.html#adding-the-build-script","text":"In the root of the package folder, add a file with the code contents of build.bat . Replace <ros package> with the name of your nuspec from above.","title":"Adding the build script"},{"location":"GettingStarted/GithubSetupCD.html#testing-the-package","text":"In later states, the pipelines will generate a zip file containing the output of your ROS package. To simulate archive generation for testing, in your terminal window, change directory into the workspace containing your package, then build with install target. Install 7zip using Chocolatey (You only need to do this the first time you try to build a package). choco install 7zip Catkin catkin_make install -DCATKIN_BUILD_BINARY_PACKAGE=ON Colcon Coming Soon","title":"Testing the package"},{"location":"GettingStarted/GithubSetupCD.html#package","text":"cd install 7z a -tzip ..\\src\\ < ros package > \\package\\tools\\drop.zip * cd ..\\src\\ < ros package > \\package build.bat If this command succeeds, you will have two nupkg files - one for pre-release in output-pre , and one release package in output . Install using the following command: choco install output-pre\\ < ros package > .1.0.0.nupkg Troubleshoot If the package fails to install correctly, the nupkg is a zip file. You can expand the zip file and examine the contents. Verify that names are spelled correctly and that the contents match. Once you find the error, you can recreate the package using build.bat, and reinstall using: choco install output-pre\\ < ros package > .1.0.0.nupkg --force NOTE: Chocolatey will remove the root folder of a zip based chocolatey package - which potentially includes other zip based packages. We recommend not uninstalling a chocolatey package for this reason.","title":"Package"},{"location":"GettingStarted/GithubSetupCD.html#manually-publish-a-chocolatey-package","text":"choco push MyPackage.1.0.0.nupkg --source https://push.chocolatey.org/","title":"Manually Publish a chocolatey package"},{"location":"GettingStarted/GithubSetupCD.html#automatically-generate-chocolatey-package-during-ci","text":"Once you've crafted your nuspec and tested the installation, you can generate the chocolatey package during CI and publish it as a release. Now create the Github Action On github, select the Action tab. Create a new workflow In the new workflow, copy the contents of CD.yaml to the newly created workflow file. Replace <ros package> with the ROS package you are generating Replace <ros nuspec> with the name of the nuspec you from above Replace <ros version> with the version from your nuspec. Whenever you create a tag in the repo, it will trigger the deployment workflow, which will publish the nupkg as a github release.","title":"Automatically generate chocolatey package during CI"},{"location":"GettingStarted/GithubSetupCD.html#updating-chocolatey-rosdep-mappings","text":"Once your chocolatey package has been published, rosdep needs to be informed of how to find it. rosdep enumerates entries in package.xml , then uses a yaml mapping file to locate the package. To update that mapping file, please follow these steps: Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork: # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < package-name > : windows: chocolatey: depends: [ < chocolatey dependencies which aren't specified in the package.xml > ] packages: [ < chocolatey-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You may encounder a warning about missing packages. On Windows some packages were collapsed into their metapackage hosting package due to differences in dependency behavior on Windows.","title":"Updating Chocolatey rosdep mappings"},{"location":"GettingStarted/GithubSetupCI.html","text":"Continuous Integration with Github Actions Actions are a feature of Github which allows you to easily integrate continuous integration into your builds. ROS1 CI Setup To configure your ROS1 repository for CI, you'll need to install the buildtime files which configures your solution for ROS building. Create the github action: On github, select the Actions tab. Create a New Workflow and name the workflow Windows_ROS1.yaml Copy the contents of Windows_ROS1.yaml and replace the contents of the file created above. Update the workflow for your ROS component. Use the comments in the file as a guide. If your ROS node has dependencies on other repositories, vcpkgs or chocolatey packages, add them before catkin_make. : Additional dependencies : For other ROS repos, remove the : and add the clone commands : pushd src : git clone https://github.com/ms-iot/audio_common : popd : For other chocolatey packages, remove the : and add the choco packages : choco install <package> : For vcpkgs, remove the : and add the vcpkg dependencies. : vcpkg install <package> ROS2 Setup To configure your ROS2 repository for CI, you'll need to install the build time files which configures your solution for ROS building. Now create the Github Action On github, select the Action tab. Create a new workflow In the new workflow, copy the contents of main.yaml to the newly created workflow file. Replace <ros package> with the ROS package you are generating","title":"Continuous Integration"},{"location":"GettingStarted/GithubSetupCI.html#continuous-integration-with-github-actions","text":"Actions are a feature of Github which allows you to easily integrate continuous integration into your builds.","title":"Continuous Integration with Github Actions"},{"location":"GettingStarted/GithubSetupCI.html#ros1-ci-setup","text":"To configure your ROS1 repository for CI, you'll need to install the buildtime files which configures your solution for ROS building. Create the github action: On github, select the Actions tab. Create a New Workflow and name the workflow Windows_ROS1.yaml Copy the contents of Windows_ROS1.yaml and replace the contents of the file created above. Update the workflow for your ROS component. Use the comments in the file as a guide. If your ROS node has dependencies on other repositories, vcpkgs or chocolatey packages, add them before catkin_make. : Additional dependencies : For other ROS repos, remove the : and add the clone commands : pushd src : git clone https://github.com/ms-iot/audio_common : popd : For other chocolatey packages, remove the : and add the choco packages : choco install <package> : For vcpkgs, remove the : and add the vcpkg dependencies. : vcpkg install <package>","title":"ROS1 CI Setup"},{"location":"GettingStarted/GithubSetupCI.html#ros2-setup","text":"To configure your ROS2 repository for CI, you'll need to install the build time files which configures your solution for ROS building. Now create the Github Action On github, select the Action tab. Create a new workflow In the new workflow, copy the contents of main.yaml to the newly created workflow file. Replace <ros package> with the ROS package you are generating","title":"ROS2 Setup"},{"location":"GettingStarted/GithubSetupCS_Linux.html","text":"Continuous Simulation Lab with GitHub Actions (Linux) Overview After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Linux VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors . Objectives Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Linux virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline. Prerequisites An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com. Exercise 1: Build And Run Autonomous Car Simulation Locally Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Ubuntu. Open a new shell. The below example assumes using bash . # Clone the github project git clone https://github.com/<your account>/ros_simulation_lab --recursive cd ros_simulation_lab # install required components sudo apt update rosdep update rosdep install --from-paths catkin_ws/src --ignore-src -r -y pip install circle-fit # build it cd catkin_ws catkin_make Run the autonomous car simulation. # source the ROS devel space. source ./devel/setup.bat # run the application roslaunch src/ar-tu-do/ros_ws/launch/gazebo.launch world: = racetrack mode_override: = 2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving. Exercise 2: Run ROSTest With Autonomous Car Simulation Locally End the previous exercise and run the following rostest file: # source the ROS devel space. source ./devel/setup.bat # run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with GitHub Actions. Exercise 3: Provision Cloud CI Environment With GitHub Actions Task 1: Fork this GitHub Project Fork ms-iot/ros_simulation_lab repository into your GitHub account. Go to your forked repository and navigate to the Actions tab. Make sure it is enabled by your permission. Task 2: Prepare Permission For Self-Hosted GitHub Runner Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT). Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner This ROS on Azure with Linux VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section. Task 4: Observe the GitHub Actions Navigate to the Actions tab and make sure workflows are listed there. Push some changes to the fork. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Continuous Simulation (Linux)"},{"location":"GettingStarted/GithubSetupCS_Linux.html#continuous-simulation-lab-with-github-actions-linux","text":"","title":"Continuous Simulation Lab with GitHub Actions (Linux)"},{"location":"GettingStarted/GithubSetupCS_Linux.html#overview","text":"After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Linux VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors .","title":"Overview"},{"location":"GettingStarted/GithubSetupCS_Linux.html#objectives","text":"Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Linux virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline.","title":"Objectives"},{"location":"GettingStarted/GithubSetupCS_Linux.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com.","title":"Prerequisites"},{"location":"GettingStarted/GithubSetupCS_Linux.html#exercise-1-build-and-run-autonomous-car-simulation-locally","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Ubuntu. Open a new shell. The below example assumes using bash . # Clone the github project git clone https://github.com/<your account>/ros_simulation_lab --recursive cd ros_simulation_lab # install required components sudo apt update rosdep update rosdep install --from-paths catkin_ws/src --ignore-src -r -y pip install circle-fit # build it cd catkin_ws catkin_make Run the autonomous car simulation. # source the ROS devel space. source ./devel/setup.bat # run the application roslaunch src/ar-tu-do/ros_ws/launch/gazebo.launch world: = racetrack mode_override: = 2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving.","title":"Exercise 1: Build And Run Autonomous Car Simulation Locally"},{"location":"GettingStarted/GithubSetupCS_Linux.html#exercise-2-run-rostest-with-autonomous-car-simulation-locally","text":"End the previous exercise and run the following rostest file: # source the ROS devel space. source ./devel/setup.bat # run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with GitHub Actions.","title":"Exercise 2: Run ROSTest With Autonomous Car Simulation Locally"},{"location":"GettingStarted/GithubSetupCS_Linux.html#exercise-3-provision-cloud-ci-environment-with-github-actions","text":"","title":"Exercise 3: Provision Cloud CI Environment With GitHub Actions"},{"location":"GettingStarted/GithubSetupCS_Linux.html#task-1-fork-this-github-project","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Go to your forked repository and navigate to the Actions tab. Make sure it is enabled by your permission.","title":"Task 1: Fork this GitHub Project"},{"location":"GettingStarted/GithubSetupCS_Linux.html#task-2-prepare-permission-for-self-hosted-github-runner","text":"Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT).","title":"Task 2: Prepare Permission For Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Linux.html#task-3-deploy-virtual-machine-and-register-as-self-hosted-github-runner","text":"This ROS on Azure with Linux VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section.","title":"Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Linux.html#task-4-observe-the-github-actions","text":"Navigate to the Actions tab and make sure workflows are listed there. Push some changes to the fork. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Task 4: Observe the GitHub Actions"},{"location":"GettingStarted/GithubSetupCS_Windows.html","text":"Continuous Simulation Lab with GitHub Actions (Windows) Overview After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors . Objectives Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline. Prerequisites An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com. Exercise 1: Build And Run Autonomous Car Simulation Locally Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Windows. Open the ROS command prompt, and run the following to build the project. : : Clone the github project git clone https://github.com/ < your account > /ros_simulation_lab --recursive cd ros_simulation_lab : : install required components vcpkg install sdl2:x64-windows pip install circle-fit : : build it cd catkin_ws catkin_make --use-ninja -DCMAKE_BUILD_TYPE=RELEASE Run the autonomous car simulation. : : source the ROS devel space. devel\\setup.bat : : run the application roslaunch src\\ar-tu-do\\ros_ws\\launch\\gazebo.launch world:=racetrack mode_override:=2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving. Exercise 2: Run ROSTest With Autonomous Car Simulation Locally End the previous exercise and run the following rostest file: : : source the ROS devel space. devel\\setup.bat : : run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with GitHub Actions. Exercise 3: Provision Cloud CI Environment With GitHub Actions Task 1: Fork this GitHub Project Fork ms-iot/ros_simulation_lab repository into your GitHub account. Go to your forked repository and navigate to the Actions tab. Make sure it is enabled by your permission. Task 2: Prepare Permission For Self-Hosted GitHub Runner Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT). Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section. Task 4: Observe the GitHub Actions Navigate to the Actions tab and make sure workflows are listed there. Push some changes to the fork. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Continuous Simulation (Windows)"},{"location":"GettingStarted/GithubSetupCS_Windows.html#continuous-simulation-lab-with-github-actions-windows","text":"","title":"Continuous Simulation Lab with GitHub Actions (Windows)"},{"location":"GettingStarted/GithubSetupCS_Windows.html#overview","text":"After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This lab uses the software developed by the Autonomous Racing Project Group of TU Dortmund . Credit goes to all the contributors .","title":"Overview"},{"location":"GettingStarted/GithubSetupCS_Windows.html#objectives","text":"Run and observe the autonomous racecar simulation locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline.","title":"Objectives"},{"location":"GettingStarted/GithubSetupCS_Windows.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com.","title":"Prerequisites"},{"location":"GettingStarted/GithubSetupCS_Windows.html#exercise-1-build-and-run-autonomous-car-simulation-locally","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Follow this ROS Wiki page to install ROS Melodic on Windows. Open the ROS command prompt, and run the following to build the project. : : Clone the github project git clone https://github.com/ < your account > /ros_simulation_lab --recursive cd ros_simulation_lab : : install required components vcpkg install sdl2:x64-windows pip install circle-fit : : build it cd catkin_ws catkin_make --use-ninja -DCMAKE_BUILD_TYPE=RELEASE Run the autonomous car simulation. : : source the ROS devel space. devel\\setup.bat : : run the application roslaunch src\\ar-tu-do\\ros_ws\\launch\\gazebo.launch world:=racetrack mode_override:=2 This launch file runs a racecar in a simulated track in Gazebo and runs autonomous driving.","title":"Exercise 1: Build And Run Autonomous Car Simulation Locally"},{"location":"GettingStarted/GithubSetupCS_Windows.html#exercise-2-run-rostest-with-autonomous-car-simulation-locally","text":"End the previous exercise and run the following rostest file: : : source the ROS devel space. devel\\setup.bat : : run the rostest rostest demo demo.test This demo.test runs the same task as the previous exercise but in headless mode. Additonally, it runs a demo.py node to kick off a validation on the latest lap time. The demo package demonstrates an example how to organize your robot simulation with the rostest framework. Now let's move this exercise to cloud-hosted environment with GitHub Actions.","title":"Exercise 2: Run ROSTest With Autonomous Car Simulation Locally"},{"location":"GettingStarted/GithubSetupCS_Windows.html#exercise-3-provision-cloud-ci-environment-with-github-actions","text":"","title":"Exercise 3: Provision Cloud CI Environment With GitHub Actions"},{"location":"GettingStarted/GithubSetupCS_Windows.html#task-1-fork-this-github-project","text":"Fork ms-iot/ros_simulation_lab repository into your GitHub account. Go to your forked repository and navigate to the Actions tab. Make sure it is enabled by your permission.","title":"Task 1: Fork this GitHub Project"},{"location":"GettingStarted/GithubSetupCS_Windows.html#task-2-prepare-permission-for-self-hosted-github-runner","text":"Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT).","title":"Task 2: Prepare Permission For Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Windows.html#task-3-deploy-virtual-machine-and-register-as-self-hosted-github-runner","text":"This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section.","title":"Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Windows.html#task-4-observe-the-github-actions","text":"Navigate to the Actions tab and make sure workflows are listed there. Push some changes to the fork. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Task 4: Observe the GitHub Actions"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html","text":"Overview After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This tutorial is to show how to use GitHub Actions to exercise the Navigation2 System Tests . It is a comprehensive End-to-End test pass with Gazebo simulation. This project is a good example for ROS 2 developers how to organize a End-to-End tests across multiple packages and tools. Objectives Run and observe the Nav2 system tests running locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline. Prerequisites An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com. Exercise 1: Build And Run Nav2 System Tests Locally Install ROS2 . Foxy is recommended. Open the ROS 2 command prompt and activate the Gazebo environment. c : \\opt\\ros\\foxy\\x64\\setup.bat c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set SDF_PATH = c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6 Create an empty workspace and clone the Navigation2 repositories. For example, : : create an empty workspace mkdir c:\\nav2_ws\\src cd c:\\nav2_ws : : clone the Navigation2 curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos Build the Navigation2 System Tests projects. : : then, build the nav2_system_tests colcon build --packages-select nav2_system_tests A few moment later, a similar message should be put to indicate a successful build: Summary: 1 package finished [2min 10s] In cases of any build failures, Log folder can be found under the workspace. Detailed information can be found there. Run the Nav2 System Tests colcon test --packages-select nav2_system_tests Verify the test result. colcon test-result Exercise 2: Provision Cloud CI Environment With GitHub Actions Task 1: Create a GitHub Repository Create a repository under your account. Go to your repository and navigate to the Actions tab. Make sure it is enabled by your permission. Task 2: Prepare Permission For Self-Hosted GitHub Runner Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT). Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section. Task 4: Create the GitHub Workflow Files The GitHub workflow is a YAML file to define what the steps to take by the GitHub runner. In this example, you will define one to checkout the code, build it and run tests. Create a file .github/workflows/build-windows.yml under your repository. name : Build and Test on Windows on : [ push ] jobs : build_and_test : runs-on : [ self-hosted , windows ] steps : - uses : actions/checkout@v2 with : submodules : recursive - name : Prepare run : | $env:ChocolateyInstall=\"c:\\opt\\chocolatey\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) choco sources add -n=roswin -s https://aka.ms/ros/public --priority 1 choco install ros-foxy-desktop -y --pre --no-progress -i shell : powershell - name : Build run : | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\Tools\\VsDevCmd.bat\" -arch=amd64 -host_arch=amd64 call \"c:\\opt\\ros\\foxy\\x64\\setup.bat\" call \"c:\\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat\" set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" mkdir ws\\src cd ws curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos colcon build --packages-select nav2_system_tests colcon test --packages-select nav2_system_tests --event-handlers console_direct+ colcon test-result shell : cmd - name : Archive test results # workaround: https://github.com/actions/upload-artifact/issues/76 run : zip -r results.zip build working-directory : ws - name : Upload test results uses : actions/upload-artifact@v2 with : path : ws/results.zip Commit and push the workflow files to your remote repository. Task 4: Observe the GitHub Actions Now a workflow should be scheduled to run under your repository. Navigate to the Actions tab and make sure workflows are listed there. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Continuous Simulation for Navigation2 System Tests"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#overview","text":"After defining your robot behavior, it is important to ensure the robot running as expected as the project iterates. The traditional unit tests and integration tests usually use the static data to exercise your code. Continous simulation demonstrates how you make use of GitHub Actions and ROS on Azure with Windows VM to run your code in Hardware-in-the-loop simulation and virtual environments. In this lab, we begin with self-driving car project with Gazebo simulation, test it on the rostest framework, and then cloud-host the continuous simulation on GitHub Actions. This tutorial is to show how to use GitHub Actions to exercise the Navigation2 System Tests . It is a comprehensive End-to-End test pass with Gazebo simulation. This project is a good example for ROS 2 developers how to organize a End-to-End tests across multiple packages and tools.","title":"Overview"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#objectives","text":"Run and observe the Nav2 system tests running locally. Deploy and register a ROS on Windows GPU optimized virtual machine on Azure. Integrate a GitHub project with GitHub Actions. Observe the simulation runs and test results on the pipeline.","title":"Objectives"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com. A GitHub account from https://github.com.","title":"Prerequisites"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#exercise-1-build-and-run-nav2-system-tests-locally","text":"Install ROS2 . Foxy is recommended. Open the ROS 2 command prompt and activate the Gazebo environment. c : \\opt\\ros\\foxy\\x64\\setup.bat c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set SDF_PATH = c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6 Create an empty workspace and clone the Navigation2 repositories. For example, : : create an empty workspace mkdir c:\\nav2_ws\\src cd c:\\nav2_ws : : clone the Navigation2 curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos Build the Navigation2 System Tests projects. : : then, build the nav2_system_tests colcon build --packages-select nav2_system_tests A few moment later, a similar message should be put to indicate a successful build: Summary: 1 package finished [2min 10s] In cases of any build failures, Log folder can be found under the workspace. Detailed information can be found there. Run the Nav2 System Tests colcon test --packages-select nav2_system_tests Verify the test result. colcon test-result","title":"Exercise 1: Build And Run Nav2 System Tests Locally"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#exercise-2-provision-cloud-ci-environment-with-github-actions","text":"","title":"Exercise 2: Provision Cloud CI Environment With GitHub Actions"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#task-1-create-a-github-repository","text":"Create a repository under your account. Go to your repository and navigate to the Actions tab. Make sure it is enabled by your permission.","title":"Task 1: Create a GitHub Repository"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#task-2-prepare-permission-for-self-hosted-github-runner","text":"Create a GitHub personal access token and select the scope of repo . Take a note of the personal access token (PAT).","title":"Task 2: Prepare Permission For Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#task-3-deploy-virtual-machine-and-register-as-self-hosted-github-runner","text":"This ROS on Azure with Windows VM is a Azure quickstart template to help setup an Azure virtual machine with ROS installed. Navigate to the template. Click Deploy to Azure . A form will be brought to you and here are some important parameters for this exercise. Virtual Machine Size : Select Standard_NV* for GPU optimized virtual machine. This is required for Gazebo. Vm Image : Select Visual Studio 2019 for the required toolchain to build project. Pipeline Provider : Select GitHubRunner to register as GitHub Self-hosted Runner. GitHub Repo : This is your GitHub account and the repository name seperated by a forward slash. For example, <your GitHub account>/ros_simulation_lab is the value of this fork. GitHub Personal Access Token : This is the PAT noted from the previous section.","title":"Task 3: Deploy Virtual Machine and Register as Self-Hosted GitHub Runner"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#task-4-create-the-github-workflow-files","text":"The GitHub workflow is a YAML file to define what the steps to take by the GitHub runner. In this example, you will define one to checkout the code, build it and run tests. Create a file .github/workflows/build-windows.yml under your repository. name : Build and Test on Windows on : [ push ] jobs : build_and_test : runs-on : [ self-hosted , windows ] steps : - uses : actions/checkout@v2 with : submodules : recursive - name : Prepare run : | $env:ChocolateyInstall=\"c:\\opt\\chocolatey\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) choco sources add -n=roswin -s https://aka.ms/ros/public --priority 1 choco install ros-foxy-desktop -y --pre --no-progress -i shell : powershell - name : Build run : | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\Tools\\VsDevCmd.bat\" -arch=amd64 -host_arch=amd64 call \"c:\\opt\\ros\\foxy\\x64\\setup.bat\" call \"c:\\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat\" set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" mkdir ws\\src cd ws curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos colcon build --packages-select nav2_system_tests colcon test --packages-select nav2_system_tests --event-handlers console_direct+ colcon test-result shell : cmd - name : Archive test results # workaround: https://github.com/actions/upload-artifact/issues/76 run : zip -r results.zip build working-directory : ws - name : Upload test results uses : actions/upload-artifact@v2 with : path : ws/results.zip Commit and push the workflow files to your remote repository.","title":"Task 4: Create the GitHub Workflow Files"},{"location":"GettingStarted/GithubSetupCS_Windows_Nav2.html#task-4-observe-the-github-actions","text":"Now a workflow should be scheduled to run under your repository. Navigate to the Actions tab and make sure workflows are listed there. Observe the runs of the workflows. And you can explore more on GitHub Help .","title":"Task 4: Observe the GitHub Actions"},{"location":"GettingStarted/NewToROS.html","text":"New ROS Users The Robot Operating System is a powerful tool for creating Robots with advanced behaviors. Using ROS is a skill by itself, and like all skills takes time and energy to become proficient and eventually master. To support the new ROS user, the ROS community create a set of tutortials which walk through the basics through advanced usage of ROS. Visit the Tutorial Wiki \u2197. These tutorials were written for ROS on Linux. While running through the tutorials, please refer to Using ROS for Windows .","title":"For new ROS Users"},{"location":"GettingStarted/NewToROS.html#new-ros-users","text":"The Robot Operating System is a powerful tool for creating Robots with advanced behaviors. Using ROS is a skill by itself, and like all skills takes time and energy to become proficient and eventually master. To support the new ROS user, the ROS community create a set of tutortials which walk through the basics through advanced usage of ROS. Visit the Tutorial Wiki \u2197. These tutorials were written for ROS on Linux. While running through the tutorials, please refer to Using ROS for Windows .","title":"New ROS Users"},{"location":"GettingStarted/PortingANode.html","text":"Porting a ROS Package to Windows A C++ ROS node on Windows is an executable or dll in the case of a nodelet. Often, a ROS node is a wrapper around one or more libraries or applications, which may require a separate Software Development Kit (SDK) or other download. This page will walk through supporting a ROS node on Windows, from porting from Linux to build and publish. ROS1 Core is supported on Windows starting with the Melodic Morenia release. ROS 2 has supported Windows since its first releases. Porting a ROS Node To port a ROS node to Windows, we recommend the following general formula. Determine if the ROS node supports Windows has a binary or source deployment using the Using ROS Node guide. Create a fork, clone locally and create a branch Resolve dependencies catkin_make in the workspace Fix Build breaks Fix linker breaks Fix runtime bugs Commit and issue a pull request Forking & Cloning. ROS1 on Windows is enabled starting in the Melodic release of ROS. Windows builds are enabled on all ROS2 distributions. In order for a ROS1 node to be ported to Windows, it must first support ROS Melodic. ROS packages typically have a tagged branch for the ROS release if there are release specific changes. Fork the repository into your account and clone the melodic branch into a workspace created for the port. On github.com, fork https://github.com/<organization>/<project> into your personal github repo Create a workspace and clone: mkdir c:\\ws\\ros_ws\\src cd c:\\ws\\ros_ws\\src git clone https://github.com/ < your github > / < project> cd .. Resolve Dependencies Many ROS packages require dependent libraries. After checking out the sources for a ROS package, the tool rosdep \u2197 is run, which will attempt to resolve package dependencies with binary and source distribution managers. On Windows, the Binary package manager Chocolatey \u2197 is used. For Source-code only distributions or dependent libraries, Microsoft's VCPkg manager \u2197 manager is used. When you install the desktop_full package, vcpkg is automatically installed and built for you. In the workspace, use rosdep to resolve dependencies rosdep update rosdep install --from-paths src --ignore-src -r -y You may see the following output indicating missing dependencies: ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies: < package: No definition of [ < dependent library > ] for OS [windows] #All required rosdeps installed successfully If there are missing dependencies, follow the steps in Using VCPKG to resolve them with existing ports or add a port using Add VCPKG as needed. Take note of special instructions printed while running rosdep - these may be needed in order to link correctly on Windows. Missing ROS Messages Many ROS Messages are not packaged as binary distributions. These can simply be cloned into the repo. cd c:\\ws\\ros_ws\\src git clone https://github.com/ < dependent package organization > / < depdnent package> cd .. rosdep install --from-paths src --ignore-src -r -y Fixing Build breaks While building you may encouter build breaks. Often, nodes depend on platform specific header files or features. In order to port these, it is recommended to leverage the cross platform equivelent in Boost, STL and cross platform libaries as part of the migration. Please refer to Porting Guide: Platform Differences for general help on porting.","title":"Porting a ROS Package"},{"location":"GettingStarted/PortingANode.html#porting-a-ros-package-to-windows","text":"A C++ ROS node on Windows is an executable or dll in the case of a nodelet. Often, a ROS node is a wrapper around one or more libraries or applications, which may require a separate Software Development Kit (SDK) or other download. This page will walk through supporting a ROS node on Windows, from porting from Linux to build and publish. ROS1 Core is supported on Windows starting with the Melodic Morenia release. ROS 2 has supported Windows since its first releases.","title":"Porting a ROS Package to Windows"},{"location":"GettingStarted/PortingANode.html#porting-a-ros-node","text":"To port a ROS node to Windows, we recommend the following general formula. Determine if the ROS node supports Windows has a binary or source deployment using the Using ROS Node guide. Create a fork, clone locally and create a branch Resolve dependencies catkin_make in the workspace Fix Build breaks Fix linker breaks Fix runtime bugs Commit and issue a pull request","title":"Porting a ROS Node"},{"location":"GettingStarted/PortingANode.html#forking-cloning","text":"ROS1 on Windows is enabled starting in the Melodic release of ROS. Windows builds are enabled on all ROS2 distributions. In order for a ROS1 node to be ported to Windows, it must first support ROS Melodic. ROS packages typically have a tagged branch for the ROS release if there are release specific changes. Fork the repository into your account and clone the melodic branch into a workspace created for the port. On github.com, fork https://github.com/<organization>/<project> into your personal github repo Create a workspace and clone: mkdir c:\\ws\\ros_ws\\src cd c:\\ws\\ros_ws\\src git clone https://github.com/ < your github > / < project> cd ..","title":"Forking &amp; Cloning."},{"location":"GettingStarted/PortingANode.html#resolve-dependencies","text":"Many ROS packages require dependent libraries. After checking out the sources for a ROS package, the tool rosdep \u2197 is run, which will attempt to resolve package dependencies with binary and source distribution managers. On Windows, the Binary package manager Chocolatey \u2197 is used. For Source-code only distributions or dependent libraries, Microsoft's VCPkg manager \u2197 manager is used. When you install the desktop_full package, vcpkg is automatically installed and built for you. In the workspace, use rosdep to resolve dependencies rosdep update rosdep install --from-paths src --ignore-src -r -y You may see the following output indicating missing dependencies: ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies: < package: No definition of [ < dependent library > ] for OS [windows] #All required rosdeps installed successfully If there are missing dependencies, follow the steps in Using VCPKG to resolve them with existing ports or add a port using Add VCPKG as needed. Take note of special instructions printed while running rosdep - these may be needed in order to link correctly on Windows.","title":"Resolve Dependencies"},{"location":"GettingStarted/PortingANode.html#missing-ros-messages","text":"Many ROS Messages are not packaged as binary distributions. These can simply be cloned into the repo. cd c:\\ws\\ros_ws\\src git clone https://github.com/ < dependent package organization > / < depdnent package> cd .. rosdep install --from-paths src --ignore-src -r -y","title":"Missing ROS Messages"},{"location":"GettingStarted/PortingANode.html#fixing-build-breaks","text":"While building you may encouter build breaks. Often, nodes depend on platform specific header files or features. In order to port these, it is recommended to leverage the cross platform equivelent in Boost, STL and cross platform libaries as part of the migration. Please refer to Porting Guide: Platform Differences for general help on porting.","title":"Fixing Build breaks"},{"location":"GettingStarted/Setup.html","text":"Setup Getting Started Firstly, go to ROS on Windows installation and follow the steps on the Wiki page. Now you are all set to further explore ROS Tutorials . If you are new to ROS on Windows, please visit the Differences between ROS on Windows and ROS on Linux page which describes some differences you'll encounter between what you see in the ROS tutorials and running on Windows. Getting Help If you need help with ROS or ROS on Windows, please check out the troubleshooting page","title":"ROS 1"},{"location":"GettingStarted/Setup.html#setup","text":"","title":"Setup"},{"location":"GettingStarted/Setup.html#getting-started","text":"Firstly, go to ROS on Windows installation and follow the steps on the Wiki page. Now you are all set to further explore ROS Tutorials . If you are new to ROS on Windows, please visit the Differences between ROS on Windows and ROS on Linux page which describes some differences you'll encounter between what you see in the ROS tutorials and running on Windows.","title":"Getting Started"},{"location":"GettingStarted/Setup.html#getting-help","text":"If you need help with ROS or ROS on Windows, please check out the troubleshooting page","title":"Getting Help"},{"location":"GettingStarted/SetupRos2.html","text":"ROS 2 on Windows Setup Windows Operating System ROS for Windows requires 64-bit Windows 10 Desktop or Windows 10 IoT Enterprise. Please ensure that you have Powershell installed and in the system path. Exclude c:\\opt (and later your workspace folder) from real-time virus Scanners, as they can interfere with install and development. Reserve space for the installation Clean and back up any existing data under c:\\opt before proceeding. c:\\opt is the required install location. Relocation is not currently enabled. Please ensure you have 10 GB of free space on the C:\\ drive for the installation and development. Install Visual Studio 2019 Building a ROS project for Windows requires Visual Studio and the Microsoft SDKs for Windows. Download Visual Studio 2019 Vcpkg is used for managing dependent libraries. It requires that the English language pack be installed. Include \"Desktop development with C++\" workload. If you already have Visual Studio 2019 installed, you can Modify Installation Install Windows Package Manager Chocolatey is a package manager for Windows. It is used to make it easy to install tools and libraries needed for building and running ROS projects. The following instructions redirect the chocolatey install location into the c:\\opt, so that you can clean or move a ROS environment from that one location. In the Start Menu, find the \"x64 Native Tools Command Prompt for VS 2019\" item. Right Click, select More then \"Run as Administrator\" Copy the following command line: @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Paste it into the command window. Approve any prompts Once it has completed, close the command prompt to complete the install. Install Git: Reopen the Visual Studio Command Window as described above. Please install Git using the command here, even if you have it installed as an application: choco upgrade git -y Close and Reopen the Visual Studio Command Window as described above. Ensure Git is now available in the Visual Studio command window: git --version Installing ROS 2 Binaries From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Open the command prompt as administrator. Run the following to install ROS 2 Foxy . mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-foxy-desktop -y --execution-timeout=0 --pre You can close the command prompt now. Now you have ROS 2 ros-foxy-desktop installed. Open a Developer Command Prompt From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Run the shortcut as administrator. Once the developer command prompt is open, run : : activate the ROS 2 environment c : \\opt\\ros\\foxy\\x64\\setup.bat : : activate the Gazebo simulation environment c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" Now you are in the ROS 2 Developer command prompt.","title":"ROS 2"},{"location":"GettingStarted/SetupRos2.html#ros-2-on-windows-setup","text":"","title":"ROS 2 on Windows Setup"},{"location":"GettingStarted/SetupRos2.html#windows-operating-system","text":"ROS for Windows requires 64-bit Windows 10 Desktop or Windows 10 IoT Enterprise. Please ensure that you have Powershell installed and in the system path. Exclude c:\\opt (and later your workspace folder) from real-time virus Scanners, as they can interfere with install and development.","title":"Windows Operating System"},{"location":"GettingStarted/SetupRos2.html#reserve-space-for-the-installation","text":"Clean and back up any existing data under c:\\opt before proceeding. c:\\opt is the required install location. Relocation is not currently enabled. Please ensure you have 10 GB of free space on the C:\\ drive for the installation and development.","title":"Reserve space for the installation"},{"location":"GettingStarted/SetupRos2.html#install-visual-studio-2019","text":"Building a ROS project for Windows requires Visual Studio and the Microsoft SDKs for Windows. Download Visual Studio 2019 Vcpkg is used for managing dependent libraries. It requires that the English language pack be installed. Include \"Desktop development with C++\" workload. If you already have Visual Studio 2019 installed, you can Modify Installation","title":"Install Visual Studio 2019"},{"location":"GettingStarted/SetupRos2.html#install-windows-package-manager","text":"Chocolatey is a package manager for Windows. It is used to make it easy to install tools and libraries needed for building and running ROS projects. The following instructions redirect the chocolatey install location into the c:\\opt, so that you can clean or move a ROS environment from that one location. In the Start Menu, find the \"x64 Native Tools Command Prompt for VS 2019\" item. Right Click, select More then \"Run as Administrator\" Copy the following command line: @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Paste it into the command window. Approve any prompts Once it has completed, close the command prompt to complete the install. Install Git: Reopen the Visual Studio Command Window as described above. Please install Git using the command here, even if you have it installed as an application: choco upgrade git -y Close and Reopen the Visual Studio Command Window as described above. Ensure Git is now available in the Visual Studio command window: git --version","title":"Install Windows Package Manager"},{"location":"GettingStarted/SetupRos2.html#installing-ros-2-binaries","text":"From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Open the command prompt as administrator. Run the following to install ROS 2 Foxy . mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-foxy-desktop -y --execution-timeout=0 --pre You can close the command prompt now. Now you have ROS 2 ros-foxy-desktop installed.","title":"Installing ROS 2 Binaries"},{"location":"GettingStarted/SetupRos2.html#open-a-developer-command-prompt","text":"From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Run the shortcut as administrator. Once the developer command prompt is open, run : : activate the ROS 2 environment c : \\opt\\ros\\foxy\\x64\\setup.bat : : activate the Gazebo simulation environment c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" Now you are in the ROS 2 Developer command prompt.","title":"Open a Developer Command Prompt"},{"location":"GettingStarted/Troubleshooting.html","text":"Troubleshooting ROS for Windows The team is monitoring ROS Answers \ud83d\udd17, ROS Discourse \ud83d\udd17, and the /r/ROS Subreddit \ud83d\udd17. This page will be updated with environment related problems as we diagnose them with customers. Windows Specific Bugs Please create a GitHub issue on the ROS on Windows GitHub repository \ud83d\udd17. No Visual Studio command line build? If you find that you do not have a Visual Studio command line in your start menu, it likely means that it wasn't installed during Visual Studio setup. To Fix, please launch the Visual Studio installer and select to install the C++ build environment. CMake Fails to find Visual Studio after upgrade CMake caches part of the build environment when building a workspace. If you upgrade Visual Studio after building, you may encounter an error like this: CMake Error in CMakeLists.txt: The CMAKE_CXX_COMPILER: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.22.27905/bin/Hostx64/x64/cl.exe To correct this situation, please delete the devel, build and install directories and rebuild: cd c:\\catkin_ws rd /s build devel install","title":"Troubleshooting"},{"location":"GettingStarted/Troubleshooting.html#troubleshooting-ros-for-windows","text":"The team is monitoring ROS Answers \ud83d\udd17, ROS Discourse \ud83d\udd17, and the /r/ROS Subreddit \ud83d\udd17. This page will be updated with environment related problems as we diagnose them with customers.","title":"Troubleshooting ROS for Windows"},{"location":"GettingStarted/Troubleshooting.html#windows-specific-bugs","text":"Please create a GitHub issue on the ROS on Windows GitHub repository \ud83d\udd17.","title":"Windows Specific Bugs"},{"location":"GettingStarted/Troubleshooting.html#no-visual-studio-command-line-build","text":"If you find that you do not have a Visual Studio command line in your start menu, it likely means that it wasn't installed during Visual Studio setup. To Fix, please launch the Visual Studio installer and select to install the C++ build environment.","title":"No Visual Studio command line build?"},{"location":"GettingStarted/Troubleshooting.html#cmake-fails-to-find-visual-studio-after-upgrade","text":"CMake caches part of the build environment when building a workspace. If you upgrade Visual Studio after building, you may encounter an error like this: CMake Error in CMakeLists.txt: The CMAKE_CXX_COMPILER: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.22.27905/bin/Hostx64/x64/cl.exe To correct this situation, please delete the devel, build and install directories and rebuild: cd c:\\catkin_ws rd /s build devel install","title":"CMake Fails to find Visual Studio after upgrade"},{"location":"GettingStarted/UsingROSonWindows.html","text":"The ROS community has many thousands of packages which cover different aspects of building a Robot. Many packages have been ported by the community or build on Windows without modification. Is the package already available? To consume a ROS package, we recommend the following workflow: Binary Installation Determine if there is a binary release of the ROS package. Using ROS Wiki \u2197, locate the binary release name and attempt to install using Chocolatey . If this succeeds, then you are all set! choco install ros-melodic- < package_name> Source Installation If there isn't a binary release, determine if there is a source only distribution. Here is an example workflow how to create a workspace to test the availability: : : activate the ROS environment c : \\opt\\ros\\melodic\\x64\\setup.bat : : create a empty workspace mkdir c:\\catkin_ws\\src cd c:\\catkin_ws : : generate the released package sources list and its ROS dependencies : : you can customize the command line to checkout the sources from different channels : : see the tips section for more details rosinstall_generator < package_name > --deps --exclude RPP --tar --flat > pkg.rosinstall : : you can manually edit the pkg.rosinstall for more customizations. : : see the tips section for more details : : checkout the sources for real wstool init src wstool merge -r -y -t src pkg.rosinstall wstool update -t src : : attempt to acquire the external dependencies rosdep update rosdep install --from-paths src --ignore-src -r -y : : now catkin make to build the workspace catkin_make If everything goes well, now you can activate the development space - by calling devel/setup.bat - and use the package. : : activate the development space devel\\setup.bat : : test the new package is discoverable rospack find < package_name> Tips for Source Installation If something has not successfully been built, you can try to the following steps: If a Windows port has not yet been released, you can repeat Soruce Installation but ask rosinstall_generator to use the development branch this time. : : use the development branch rosinstall_generator < package > --upstream-development --deps --exclude RPP > pkg.rosinstall If using the upstream development branch doesn't help, you can edit pkg.rosinstall to switch the version: of the broken package to other branch, like windows or init_windows , if it exists. In addition to consuming the upstream repositories, you can check to see if Microsoft's ms-iot Github organization has a fork of that project and is working on a port. If it does, you can edit pkg.rosinstall to point uri: to the different fork. For the package not registered to the ROS distributions , you can manually create a .rosinstall file to maintain a list of repositories to consume. ROS Wiki or ROS Index are also good resources to search for the package repository. Contribute If the package has not been enabled on Windows, please create an issue on the ROS package's project page asking for Windows to be supported. If you are able, please consider enabling the ROS package on Windows and submitting a pull request to the original repository. Porting a ROS Package is a good resource to learn the how-to.","title":"Consuming a ROS Package"},{"location":"GettingStarted/UsingROSonWindows.html#is-the-package-already-available","text":"To consume a ROS package, we recommend the following workflow:","title":"Is the package already available?"},{"location":"GettingStarted/UsingROSonWindows.html#binary-installation","text":"Determine if there is a binary release of the ROS package. Using ROS Wiki \u2197, locate the binary release name and attempt to install using Chocolatey . If this succeeds, then you are all set! choco install ros-melodic- < package_name>","title":"Binary Installation"},{"location":"GettingStarted/UsingROSonWindows.html#source-installation","text":"If there isn't a binary release, determine if there is a source only distribution. Here is an example workflow how to create a workspace to test the availability: : : activate the ROS environment c : \\opt\\ros\\melodic\\x64\\setup.bat : : create a empty workspace mkdir c:\\catkin_ws\\src cd c:\\catkin_ws : : generate the released package sources list and its ROS dependencies : : you can customize the command line to checkout the sources from different channels : : see the tips section for more details rosinstall_generator < package_name > --deps --exclude RPP --tar --flat > pkg.rosinstall : : you can manually edit the pkg.rosinstall for more customizations. : : see the tips section for more details : : checkout the sources for real wstool init src wstool merge -r -y -t src pkg.rosinstall wstool update -t src : : attempt to acquire the external dependencies rosdep update rosdep install --from-paths src --ignore-src -r -y : : now catkin make to build the workspace catkin_make If everything goes well, now you can activate the development space - by calling devel/setup.bat - and use the package. : : activate the development space devel\\setup.bat : : test the new package is discoverable rospack find < package_name>","title":"Source Installation"},{"location":"GettingStarted/UsingROSonWindows.html#tips-for-source-installation","text":"If something has not successfully been built, you can try to the following steps: If a Windows port has not yet been released, you can repeat Soruce Installation but ask rosinstall_generator to use the development branch this time. : : use the development branch rosinstall_generator < package > --upstream-development --deps --exclude RPP > pkg.rosinstall If using the upstream development branch doesn't help, you can edit pkg.rosinstall to switch the version: of the broken package to other branch, like windows or init_windows , if it exists. In addition to consuming the upstream repositories, you can check to see if Microsoft's ms-iot Github organization has a fork of that project and is working on a port. If it does, you can edit pkg.rosinstall to point uri: to the different fork. For the package not registered to the ROS distributions , you can manually create a .rosinstall file to maintain a list of repositories to consume. ROS Wiki or ROS Index are also good resources to search for the package repository.","title":"Tips for Source Installation"},{"location":"GettingStarted/UsingROSonWindows.html#contribute","text":"If the package has not been enabled on Windows, please create an issue on the ROS package's project page asking for Windows to be supported. If you are able, please consider enabling the ROS package on Windows and submitting a pull request to the original repository. Porting a ROS Package is a good resource to learn the how-to.","title":"Contribute"},{"location":"GettingStarted/UsingVCPKG.html","text":"Using a C++ Dependency in a ROS Node using vcpkg If you find that a dependency is not met with vcpkg today, that dependency can be added by following the vcpkg guide Updating vcpkg mappings Often the name of a a library on Linux differs from the name on vcpkg. In order to address this, a mapping file called vcpkg.yaml is part of the rosditro database. This creates a mapping between the Linux name for the package and the vcpkg name. Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account, if you haven't already Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork. # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package, to the name used in vcpkg. You can edit this file directly on github in your fork. The format of the vcpkg.yaml: Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < linux--package-name > : windows: vcpkg: packages: [ < vcpkg-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You'll see that the dependency resolves correctly. However, you may be provided with instructions for using that library in ROS nodes: The package < library > :x64-windows provides CMake targets: find_package( < package > CONFIG REQUIRED) target_link_libraries(main PRIVATE < package > <package > :: < namespace > ) These may differ from how linkage happes on Linux. To link this library, to support both Windows and Linux, you can wrap it: if (MSVC) target_link_libraries(main PRIVATE < package > <package > :: < namespace > ) else() target_link_libraries(main ... < original > ) endif Handling RelWithDebinfo ROS on Windows is delivered with Release binaries that have been built with Debug Info (using cmake's RelWithDebInfo target). When interacting with vcpkg, cmake will map RelWithDebInfo built binaries to Debug binaries. This mismatch will cause problems. To correct this, add the following to the cmake for the ROS node: set_target_properties(${ < dependency_LIBRARIES} PROPERTIES MAP_IMPORTED_CONFIG_RELWITHDEBINFO RELEASE)","title":"Using a C++ Dependency"},{"location":"GettingStarted/UsingVCPKG.html#using-a-c-dependency-in-a-ros-node-using-vcpkg","text":"If you find that a dependency is not met with vcpkg today, that dependency can be added by following the vcpkg guide","title":"Using a C++ Dependency in a ROS Node using vcpkg"},{"location":"GettingStarted/UsingVCPKG.html#updating-vcpkg-mappings","text":"Often the name of a a library on Linux differs from the name on vcpkg. In order to address this, a mapping file called vcpkg.yaml is part of the rosditro database. This creates a mapping between the Linux name for the package and the vcpkg name. Fork https://github.com/ms-iot/rosdistro-db \u2197 into your github account, if you haven't already Create a file called 0-update.list in c:\\opt\\ros\\melodic\\x64\\etc\\ros\\rosdep\\sources.list.d In this file, add a line which points to your fork. # os-specific listings first yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/win-chocolatey.yaml windows yaml https://raw.githubusercontent.com/ < your github > /rosdistro-db/init_windows/rosdep/vcpkg.yaml windows Add a mapping from the dependency name used in the ROS package, to the name used in vcpkg. You can edit this file directly on github in your fork. The format of the vcpkg.yaml: Python < python-package-name > : windows: pip: packages: [ < python-package-name-in-pip > ] C++ < linux--package-name > : windows: vcpkg: packages: [ < vcpkg-name > ] Update rosdeps on your computer. rosdep update rosdep install --from-paths src --ignore-src -r -y You'll see that the dependency resolves correctly. However, you may be provided with instructions for using that library in ROS nodes: The package < library > :x64-windows provides CMake targets: find_package( < package > CONFIG REQUIRED) target_link_libraries(main PRIVATE < package > <package > :: < namespace > ) These may differ from how linkage happes on Linux. To link this library, to support both Windows and Linux, you can wrap it: if (MSVC) target_link_libraries(main PRIVATE < package > <package > :: < namespace > ) else() target_link_libraries(main ... < original > ) endif Handling RelWithDebinfo ROS on Windows is delivered with Release binaries that have been built with Debug Info (using cmake's RelWithDebInfo target). When interacting with vcpkg, cmake will map RelWithDebInfo built binaries to Debug binaries. This mismatch will cause problems. To correct this, add the following to the cmake for the ROS node: set_target_properties(${ < dependency_LIBRARIES} PROPERTIES MAP_IMPORTED_CONFIG_RELWITHDEBINFO RELEASE)","title":"Updating vcpkg mappings"},{"location":"GettingStarted/VcpkgAsRosdep.html","text":"Why we marry Vcpkg with Rosdep Today, many ROS packages consume OSS libraries which are much beyond ROS on Windows Chocolatey server for Open Robotics core packages. To enable developers lighting up more ROS packages on Windows, we leverage the Vcpkg community (which has 1000+ OSS libraries ports), and extend rosdep to manage Vcpkg packages which are known to work with ROS on Windows installation. It means ROS developer can either consume the OOS libraries right away if they are in Vcpkg ports, or they can contribute Vcpkg ports back which benefit ROS community. Example Workflow Let's take koboki as an example. After checking out the source code and running rosdep check , two missing requirements are reported from here: libusb-dev and libftdi-dev . They are the rosdep keys, so you will need another look up to see what's the actual package names for platforms. By checking index.ros.org , they are found as libusb-dev and libftdi-dev respectively on Ubuntu. By a further check, they are registered as libftdi-dev (0.20-4build3) and libusb-dev (2:0.1.12-31) on packages.ubuntu.com , which gives us an idea what version to use. Back to Vcpkg, libusb-dev can be found as libusb-win32 . You can do vcpkg install libusb-win32:x64-windows from the ROS command prompt. Since Vcpkg is integrated with your ROS installation already, developers can do catkin_make to iterate on Windows port work. And in this example, libftdi-dev is not found in Vcpkg. It is because the library is not ported yet in Vcpkg. You can make a Vcpkg port for it, and contributethe Vcpkg recipe back to Microsoft\\Vcpkg . As of today, a port for libftdi-dev is contributed back to Vcpkg . After a Windows port finished, developers can send pull request to register Vcpkg port to Rosdep keys (https://github.com/ms-iot/rosdistro-db/blob/init_windows/rosdep/vcpkg.yaml). So the next time for who wants to build koboki, installing the system dependencies can be simplified to by running rosdep install . How do I try it out This new integration is avaiable in the build of 20190617.1.0-pre and above. To try it out, run Chocolatey upgrade to use the prerelease builds: choco upgrade ros-melodic-desktop_full -y --pre Feedback For any feedback, please open an issue on ms-iot\\ROSOnWindows . We will help you there.","title":"VcpkgAsRosdep"},{"location":"GettingStarted/VcpkgAsRosdep.html#why-we-marry-vcpkg-with-rosdep","text":"Today, many ROS packages consume OSS libraries which are much beyond ROS on Windows Chocolatey server for Open Robotics core packages. To enable developers lighting up more ROS packages on Windows, we leverage the Vcpkg community (which has 1000+ OSS libraries ports), and extend rosdep to manage Vcpkg packages which are known to work with ROS on Windows installation. It means ROS developer can either consume the OOS libraries right away if they are in Vcpkg ports, or they can contribute Vcpkg ports back which benefit ROS community.","title":"Why we marry Vcpkg with Rosdep"},{"location":"GettingStarted/VcpkgAsRosdep.html#example-workflow","text":"Let's take koboki as an example. After checking out the source code and running rosdep check , two missing requirements are reported from here: libusb-dev and libftdi-dev . They are the rosdep keys, so you will need another look up to see what's the actual package names for platforms. By checking index.ros.org , they are found as libusb-dev and libftdi-dev respectively on Ubuntu. By a further check, they are registered as libftdi-dev (0.20-4build3) and libusb-dev (2:0.1.12-31) on packages.ubuntu.com , which gives us an idea what version to use. Back to Vcpkg, libusb-dev can be found as libusb-win32 . You can do vcpkg install libusb-win32:x64-windows from the ROS command prompt. Since Vcpkg is integrated with your ROS installation already, developers can do catkin_make to iterate on Windows port work. And in this example, libftdi-dev is not found in Vcpkg. It is because the library is not ported yet in Vcpkg. You can make a Vcpkg port for it, and contributethe Vcpkg recipe back to Microsoft\\Vcpkg . As of today, a port for libftdi-dev is contributed back to Vcpkg . After a Windows port finished, developers can send pull request to register Vcpkg port to Rosdep keys (https://github.com/ms-iot/rosdistro-db/blob/init_windows/rosdep/vcpkg.yaml). So the next time for who wants to build koboki, installing the system dependencies can be simplified to by running rosdep install .","title":"Example Workflow"},{"location":"GettingStarted/VcpkgAsRosdep.html#how-do-i-try-it-out","text":"This new integration is avaiable in the build of 20190617.1.0-pre and above. To try it out, run Chocolatey upgrade to use the prerelease builds: choco upgrade ros-melodic-desktop_full -y --pre","title":"How do I try it out"},{"location":"GettingStarted/VcpkgAsRosdep.html#feedback","text":"For any feedback, please open an issue on ms-iot\\ROSOnWindows . We will help you there.","title":"Feedback"},{"location":"GettingStarted/build.html","text":"name : <ros package> CI on : pull_request : push : branches : - master schedule : # Run every hour. This helps detect flakiness, # and broken external dependencies. - cron : '0 * * * *' jobs : build_and_test : runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ windows-latest ] steps : - uses : actions/checkout@v2 - name : Cleanup windows environment shell : bash run : | rm -rf /c/hostedtoolcache/windows/Boost/1.72.0/lib/cmake/Boost-1.72.0 mkdir -p /c/ci cp $GITHUB_WORKSPACE/ci/toolchain.cmake /c/ci - uses : goanpeca/setup-miniconda@v1 with : activate-environment : myenv environment-file : ci/environment.yaml python-version : 3.7 - uses : ros-tooling/action-ros-ci@master with : package-name : <ros package> vcs-repo-file-url : ${{ github.workspace }}/ci/deps.rosinstall extra-cmake-args : \"-G Ninja -DCMAKE_TOOLCHAIN_FILE=c:/ci/toolchain.cmake -DCATKIN_SKIP_TESTING=ON -DCMAKE_BUILD_TYPE=Release\" env : COLCON_DEFAULTS_FILE : ${{ github.workspace }}/ci/defaults.yaml ROS_PYTHON_VERSION : 3 CC : cl.exe CXX : cl.exe","title":"Build"},{"location":"GettingStarted/choco_build.html","text":"@ echo off : : seed ROS_DISTRO for the install scripts. echo set \"ROS_DISTRO= %ROS_DISTRO% \" >> tools\\setup.bat echo set \"ROS_ETC_DIR= %ROS_ETC_DIR% \" >> tools\\setup.bat echo set \"PYTHONHOME= %PYTHON_LOCATION% \" >> tools\\setup.bat echo set \"ROS_PYTHON_VERSION= %ROS_PYTHON_VERSION% \" >> tools\\setup.bat : : create Chocolatey packages. md output choco pack --trace --out output < ros package > .nuspec md output-pre choco pack --trace --out output-pre < ros package > .nuspec","title":"Choco build"},{"location":"GettingStarted/choco_template.html","text":"<?xml version=\"1.0\"?> <package xmlns= \"http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd\" > <metadata> <id> MyPackage </id> <version> 1.0.0 </version> <title> MyPackage ROS package </title> <authors> My Name </authors> <licenseUrl> http://www.github.com/MyOrg/MyPackage/License.txt </licenseUrl> <projectUrl> http://www.github.com/MyOrg/MyPackage </projectUrl> <requireLicenseAcceptance> false </requireLicenseAcceptance> <description> MyPackage for ROS on Windows. </description> <summary> MyPackage packaged as a rosdep. </summary> <tags> ros MyPackage </tags> <packageSourceUrl> http://www.github.com/MyOrg/MyPackage </packageSourceUrl> <docsUrl> http://www.github.com/MyOrg/MyPackage/Docs </docsUrl> </metadata> </package>","title":"Choco template"},{"location":"GettingStarted/chocolateyInstall_template.html","text":"$ErrorActionPreference = 'Stop' ; $packageName = $env:ChocolateyPackageName $toolsDir = \" $( Split-Path -parent $MyInvocation . MyCommand . Definition ) \" $fileLocation = Join-Path $toolsDir 'drop.zip' $packageArgs = @{ packageName = $packageName destination = $destination fileFullPath64 = $fileLocation } # - https://chocolatey.org/docs/helpers-get-chocolatey-unzip Get-ChocolateyUnzip @packageArgs Write-Host 'running rosdep...' $ErrorActionPreference = 'SilentlyContinue' ; $rosdepInstall = Join-Path $toolsDir 'rosdepInstall.bat' Start-Process -FilePath \"$env:comspec\" -Wait -NoNewWindow -ArgumentList \"/c\" , $rosdepInstall","title":"chocolateyInstall template"},{"location":"GettingStarted/defaults.html","text":"{ \"build\" : { \"symlink-install\" : true , \"event-handlers\" : [ \"console_cohesion+\" ], \"catkin-cmake-args\" : [ \"-DCATKIN_SKIP_TESTING=ON\" , \"-DCMAKE_PREFIX_PATH=c:/miniconda/envs/myenv/library\" ], \"install-base\" : \"c:\\\\miniconda\\\\envs\\\\myenv\\\\library\" , \"parallel-workers\" : 1 , \"merge-install\" : true }, \"test\" : { \"merge-install\" : true , \"install-base\" : \"c:\\\\miniconda\\\\envs\\\\myenv\\\\library\" } }","title":"Defaults"},{"location":"GettingStarted/deps.html","text":"- git : local-name : actionlib uri : https://github.com/ros/actionlib.git version : melodic-devel - git : local-name : angles uri : https://github.com/ros/angles.git version : master - git : local-name : bond_core uri : https://github.com/ros/bond_core.git version : kinetic-devel - git : local-name : catkin uri : https://github.com/ros/catkin.git version : kinetic-devel - git : local-name : class_loader uri : https://github.com/ros/class_loader.git version : melodic-devel - git : local-name : cmake_modules uri : https://github.com/ros/cmake_modules.git version : 0.4-devel - git : local-name : common_msgs uri : https://github.com/ros/common_msgs.git version : jade-devel - git : local-name : gencpp uri : https://github.com/ros/gencpp.git version : kinetic-devel - git : local-name : geneus uri : https://github.com/jsk-ros-pkg/geneus.git version : master - git : local-name : genlisp uri : https://github.com/ros/genlisp.git version : kinetic-devel - git : local-name : genmsg uri : https://github.com/ros/genmsg.git version : kinetic-devel - git : local-name : gennodejs uri : https://github.com/RethinkRobotics-opensource/gennodejs.git version : kinetic-devel - git : local-name : genpy uri : https://github.com/ros/genpy.git version : kinetic-devel - git : local-name : geometry2 uri : https://github.com/ros/geometry2.git version : melodic-devel - git : local-name : image_common uri : https://github.com/ros-perception/image_common.git version : hydro-devel - git : local-name : message_generation uri : https://github.com/ros/message_generation.git version : kinetic-devel - git : local-name : message_runtime uri : https://github.com/ros/message_runtime.git version : kinetic-devel - git : local-name : nodelet_core uri : https://github.com/ros/nodelet_core.git version : indigo-devel - git : local-name : orocos_kinematics_dynamics uri : https://github.com/orocos/orocos_kinematics_dynamics.git version : master - git : local-name : pluginlib uri : https://github.com/ros/pluginlib.git version : melodic-devel - git : local-name : ros uri : https://github.com/ros/ros.git version : kinetic-devel - git : local-name : ros_comm uri : https://github.com/ros/ros_comm.git version : melodic-devel - git : local-name : ros_comm_msgs uri : https://github.com/ros/ros_comm_msgs.git version : kinetic-devel - git : local-name : ros_environment uri : https://github.com/ros/ros_environment.git version : melodic - git : local-name : rosconsole uri : https://github.com/ros/rosconsole.git version : melodic-devel - git : local-name : roscpp_core uri : https://github.com/ros/roscpp_core.git version : kinetic-devel - git : local-name : roslint uri : https://github.com/ros/roslint.git version : master - git : local-name : rospack uri : https://github.com/ros/rospack.git version : melodic-devel - git : local-name : std_msgs uri : https://github.com/ros/std_msgs.git version : kinetic-devel - git : local-name : vision_opencv uri : https://github.com/ms-iot/vision_opencv.git version : windows_py3 - git : local-name : xacro uri : https://github.com/ros/xacro.git version : melodic-devel - git : local-name : geometry uri : https://github.com/ms-iot/geometry.git version : init_windows - git : local-name : interactive_markers uri : https://github.com/ms-iot/interactive_markers.git version : init_windows","title":"Deps"},{"location":"GettingStarted/empty.html","text":"repositories :","title":"Empty"},{"location":"GettingStarted/environment.html","text":"name : myenv channels : - conda-forge - defaults dependencies : - python=3.7 - colcon-common-extensions - vcstool - rosdep - console_bridge - boost=1.69 - tinyxml2 - poco - bzip2 - lz4-c - opencv=3 - eigen","title":"Environment"},{"location":"GettingStarted/packaging.html","text":"{ \"build\" : { \"symlink-install\" : true , \"event-handlers\" : [ \"console_cohesion+\" ], \"catkin-cmake-args\" : [ \"-DCATKIN_SKIP_TESTING=ON\" , \"-DCMAKE_PREFIX_PATH=c:/miniconda/envs/myenv/library;c:/opt/install\" , \"-DCATKIN_BUILD_BINARY_PACKAGE=ON\" ], \"install-base\" : \"c:\\\\opt\\\\install\" , \"parallel-workers\" : 1 , \"merge-install\" : true }, \"test\" : { \"merge-install\" : true , \"install-base\" : \"c:\\\\opt\\\\install\" } }","title":"Packaging"},{"location":"GettingStarted/ros1_workflow.html","text":"name : CI on : pull_request : push : branches : - master schedule : # every Monday - cron : '0 0 * * 1' jobs : build : runs-on : [ windows-latest ] strategy : fail-fast : false matrix : ROSDISTRO : [ melodic , noetic ] steps : - uses : actions/checkout@v2 with : submodules : recursive path : src - name : Install shell : cmd run : | choco sources add -n=roswin -s https://aka.ms/ros/public --priority 1 choco install ros-%ROSDISTRO%-desktop_full -y --no-progress : The desktop_full deployment has a chocolatey deployment which is isolated to the ROS distro : (so they don't conflict with each other) : If you need other dependencies, they should go after setup.bat in the following block in order : to be injected into the isolated deployment. env : ROSDISTRO : ${{ matrix.ROSDISTRO }} - name : Build shell : cmd run : | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\Common7\\Tools\\VsDevCmd.bat\" -arch=amd64 -host_arch=amd64 call \"C:\\opt\\ros\\%ROSDISTRO%\\x64\\setup.bat\" : Additional dependencies after setup.bat. : For other ROS repos, remove the : and add the clone commands : pushd src : git clone https://github.com/ms-iot/audio_common : popd : For other chocolatey packages, remove the : and add the choco packages : choco install <package> : For vcpkgs, remove the : and add the vcpkg dependencies. : vcpkg install <package> catkin_make install -DPYTHON_EXECUTABLE=C:\\opt\\ros\\%ROSDISTRO%\\x64\\python.exe env : ROSDISTRO : ${{ matrix.ROSDISTRO }} - uses : actions/upload-artifact@v1 with : name : drop path : install","title":"Ros1 workflow"},{"location":"GettingStarted/ros1_workflow_pub.html","text":"name : CD on : push : # Sequence of patterns matched against refs/tags tags : - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10 jobs : build_and_test : runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ windows-latest ] steps : - uses : actions/checkout@v2 - name : Cleanup windows environment shell : bash run : | rm -rf /c/hostedtoolcache/windows/Boost/1.72.0/lib/cmake/Boost-1.72.0 mkdir -p /c/ci cp $GITHUB_WORKSPACE/ci/toolchain.cmake /c/ci - uses : goanpeca/setup-miniconda@v1 with : activate-environment : myenv environment-file : ci/environment.yaml python-version : 3.7 - uses : ros-tooling/action-ros-ci@master with : package-name : <ros package> vcs-repo-file-url : ${{ github.workspace }}/ci/deps.rosinstall extra-cmake-args : \"-G Ninja -DCMAKE_TOOLCHAIN_FILE=c:/ci/toolchain.cmake -DCMAKE_BUILD_TYPE=Release\" env : COLCON_DEFAULTS_FILE : ${{ github.workspace }}/ci/defaults.yaml ROS_PYTHON_VERSION : 3 CC : cl.exe CXX : cl.exe - uses : ros-tooling/action-ros-ci@master with : package-name : winml_tracker vcs-repo-file-url : ${{ github.workspace }}/ci/empty.rosinstall extra-cmake-args : \"-G Ninja -DCMAKE_TOOLCHAIN_FILE=c:/ci/toolchain.cmake -DCMAKE_BUILD_TYPE=Release\" env : COLCON_DEFAULTS_FILE : ${{ github.workspace }}/ci/packaging.yaml ROS_PYTHON_VERSION : 3 CC : cl.exe CXX : cl.exe - name : Build Chocolatey Package shell : cmd run : | cd c:\\opt\\install 7z a -tzip ${{ github.workspace }}\\package\\tools\\drop.zip * echo $destination = 'c:\\opt\\ros\\melodic\\x64' > ${{ github.workspace }}\\package\\tools\\chocolateyInstall.ps1 type $GITHUB_WORKSPACE\\package\\chocolateyInstall_template.ps1 >> ${{ github.workspace }}\\package\\tools\\chocolateyInstall.ps1 mkdir c:\\opt\\output cd ${{ github.workspace }}\\package choco pack --trace --out c:\\opt\\output <ros nuspec>.nuspec - name : Create Release id : create_release uses : actions/create-release@v1 env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : tag_name : ${{ github.ref }} release_name : Release ${{ github.ref }} draft : false prerelease : false - name : Upload Release Asset id : upload-release-asset uses : actions/upload-release-asset@v1 env : GITHUB_TOKEN : ${{ secrets.GITHUB_TOKEN }} with : upload_url : ${{ steps.create_release.outputs.upload_url }} asset_path : c:/opt/output/<ros nuspec>.<ros version>.nupkg asset_name : <ros nuspec>.<ros version>.nupkg asset_content_type : application/zip","title":"Ros1 workflow pub"},{"location":"GettingStarted/ros2_workflow.html","text":"name : Build on : pull_request : push : branches : - master schedule : # Run every hour. This helps detect flakiness, # and broken external dependencies. - cron : '0 * * * *' jobs : build_and_test : runs-on : ${{ matrix.os }} strategy : fail-fast : false matrix : os : [ ubuntu-latest , windows-latest ] steps : - uses : ros-tooling/setup-ros@0.0.15 - uses : ros-tooling/action-ros-ci@master with : package-name : <ros package> - uses : actions/upload-artifact@v1 with : name : drop path : c:\\opt\\install","title":"Ros2 workflow"},{"location":"GettingStarted/rosdepInstall.html","text":"@ echo off setlocal : : source ROS environments pushd %~dp0 call \"setup.bat\" : : use Python from ROS installation set PATH = %PYTHONHOME% ; %PYTHONHOME% \\Scripts; %PATH% set PYTHONPATH = : : install ROS system dependencies rosdep init rosdep update rosdep install --from-paths c:\\opt\\ros\\ %ROS_DISTRO% \\x64\\share --ignore-src -r -y","title":"rosdepInstall"},{"location":"GettingStarted/toolchain.html","text":"ADD_DEFINITIONS(-DBOOST_ALL_DYN_LINK=1)","title":"Toolchain"},{"location":"Moveit/UR3.html","text":"Getting Started with MoveIt and UR3 on Windows Getting Started with the MoveIt and UR3 on Windows. If you are new to MoveIt or you don't have a real robot, check out MoveIt Tutorials on Windows . Prerequisite This guide assumes you had hands-on experience on running ROSOnWindows from this document. (https://ms-iot.github.io/ROSOnWindows/GettingStarted/Setup.html) This guide requires you have an Universal Robot UR3 with a software version (3.x) MoveIt and UR3 on Windows Installation First, you can get started by installing moveit related packages from ROSOnWindows Chocolatey server. (open a command prompt as admin) choco upgrade ros-melodic-desktop_full -y choco upgrade ros-melodic-moveit -y Then, create a workspace, checkout and build the Universal Robot Driver for UR3. (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat mkdir c:\\catkin_ws\\src cd c:\\catkin_ws\\src git clone https://github.com/ms-iot/universal_robot -b init_windows git clone https://github.com/ms-iot/ur_modern_driver -b init_windows cd c:\\catkin_ws catkin_make c : \\catkin_ws\\devel\\setup.bat Now you are almost good to go to run UR3 launch files. Before proceeding, make sure your UR3 controller is on and the network is connected to your dev box. Running UR3 Launch Files Now let's run it! In this example, it requires three launch files to run: One is to run the UR3 driver stack for planning execution, one is to run the UR3 motion planning, and the other one is to run the visualization tool. Let's start the UR3 driver stack: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur_modern_driver ur3_bringup.launch robot_ip:=IP_OF_THE_ROBOT use_lowbandwidth_trajectory_follower:=true Second, run the UR3 motion planning: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur3_moveit_config ur3_moveit_planning_execution.launch Finally, run the visualization tool: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur3_moveit_config moveit_rviz.launch config:=true Known Issue: When you don't see all panels displayed in RViz, try to enter full screen mode and exit (F11) to refresh the windows rendering. Now you are ready to move the robot arm in the visualization tool and start planning and see your arm moving in action! Troubleshoot The arm fails to move and Invalid Trajectory: start point deviates from current robot state more than ... shows in motion planning console window. It is likely the default value of allowed_start_tolerance being too small for you. Before figuring out a reasonable value, edit ur3_moveit_config/launch/move_group.launch and adding allowed_start_tolerance can help: <node name= \"move_group\" launch-prefix= \"$(arg launch_prefix)\" pkg= \"moveit_ros_move_group\" type= \"move_group\" respawn= \"false\" output= \"screen\" args= \"$(arg command_args)\" > ... <!-- default 0.01, disable 0.0 --> <param name= \"trajectory_execution/allowed_start_tolerance\" value= \"0.0\" /> </node> More Information ur_modern_driver MoveIt Tutorials","title":"Universal Robot UR3"},{"location":"Moveit/UR3.html#getting-started-with-moveit-and-ur3-on-windows","text":"Getting Started with the MoveIt and UR3 on Windows. If you are new to MoveIt or you don't have a real robot, check out MoveIt Tutorials on Windows .","title":"Getting Started with MoveIt and UR3 on Windows"},{"location":"Moveit/UR3.html#prerequisite","text":"This guide assumes you had hands-on experience on running ROSOnWindows from this document. (https://ms-iot.github.io/ROSOnWindows/GettingStarted/Setup.html) This guide requires you have an Universal Robot UR3 with a software version (3.x)","title":"Prerequisite"},{"location":"Moveit/UR3.html#moveit-and-ur3-on-windows-installation","text":"First, you can get started by installing moveit related packages from ROSOnWindows Chocolatey server. (open a command prompt as admin) choco upgrade ros-melodic-desktop_full -y choco upgrade ros-melodic-moveit -y Then, create a workspace, checkout and build the Universal Robot Driver for UR3. (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat mkdir c:\\catkin_ws\\src cd c:\\catkin_ws\\src git clone https://github.com/ms-iot/universal_robot -b init_windows git clone https://github.com/ms-iot/ur_modern_driver -b init_windows cd c:\\catkin_ws catkin_make c : \\catkin_ws\\devel\\setup.bat Now you are almost good to go to run UR3 launch files. Before proceeding, make sure your UR3 controller is on and the network is connected to your dev box.","title":"MoveIt and UR3 on Windows Installation"},{"location":"Moveit/UR3.html#running-ur3-launch-files","text":"Now let's run it! In this example, it requires three launch files to run: One is to run the UR3 driver stack for planning execution, one is to run the UR3 motion planning, and the other one is to run the visualization tool. Let's start the UR3 driver stack: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur_modern_driver ur3_bringup.launch robot_ip:=IP_OF_THE_ROBOT use_lowbandwidth_trajectory_follower:=true Second, run the UR3 motion planning: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur3_moveit_config ur3_moveit_planning_execution.launch Finally, run the visualization tool: (open a command prompt as admin) c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\catkin_ws\\devel\\setup.bat roslaunch ur3_moveit_config moveit_rviz.launch config:=true Known Issue: When you don't see all panels displayed in RViz, try to enter full screen mode and exit (F11) to refresh the windows rendering. Now you are ready to move the robot arm in the visualization tool and start planning and see your arm moving in action!","title":"Running UR3 Launch Files"},{"location":"Moveit/UR3.html#troubleshoot","text":"The arm fails to move and Invalid Trajectory: start point deviates from current robot state more than ... shows in motion planning console window. It is likely the default value of allowed_start_tolerance being too small for you. Before figuring out a reasonable value, edit ur3_moveit_config/launch/move_group.launch and adding allowed_start_tolerance can help: <node name= \"move_group\" launch-prefix= \"$(arg launch_prefix)\" pkg= \"moveit_ros_move_group\" type= \"move_group\" respawn= \"false\" output= \"screen\" args= \"$(arg command_args)\" > ... <!-- default 0.01, disable 0.0 --> <param name= \"trajectory_execution/allowed_start_tolerance\" value= \"0.0\" /> </node>","title":"Troubleshoot"},{"location":"Moveit/UR3.html#more-information","text":"ur_modern_driver MoveIt Tutorials","title":"More Information"},{"location":"Moveit/moveit_tutorials.html","text":"MoveIt Tutorials on Windows This guide is to show you how to prepare a workspace for MoveIt tutorials. Find out more about MoveIt, visit here . MoveIt Binary Installation on Windows Download the ROS on Windows with MoveIt packages. (open an elevated ROS Command Window as described in the installation instructions) Noetic mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-noetic-desktop_full -y --execution-timeout=0 Melodic mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-melodic-moveit -y --execution-timeout=0 Create Workspace for MoveIt Tutorials Then, create a workspace and download the example code. (open a command prompt as admin) Noetic : : activate ROS environment c : \\opt\\ros\\noetic\\x64\\setup.bat : : checkout MoveIt tutorial packages mkdir c:\\moveit_ws\\src cd c:\\moveit_ws\\src git clone https://github.com/ros-planning/moveit_tutorials.git -b melodic-devel git clone https://github.com/ros-planning/panda_moveit_config.git -b melodic-devel git clone https://github.com/frankaemika/franka_ros-release -b release/kinetic/franka_description : : build packages cd c:\\moveit_ws catkin_make Melodic : : activate ROS environment c : \\opt\\ros\\melodic\\x64\\setup.bat : : checkout MoveIt tutorial packages mkdir c:\\moveit_ws\\src cd c:\\moveit_ws\\src git clone https://github.com/ros-planning/moveit_tutorials.git -b melodic-devel git clone https://github.com/ros-planning/panda_moveit_config.git -b melodic-devel git clone https://github.com/frankaemika/franka_ros-release -b release/kinetic/franka_description : : build packages cd c:\\moveit_ws catkin_make After it is built, activate the development workspace. c : \\moveit_ws\\devel\\setup.bat Getting Started with MoveIt Tutorials Now you are ready to continue to the MoveIt Quickstart in RViz section of the tutorials MoveIt Tutorials .","title":"MoveIt"},{"location":"Moveit/moveit_tutorials.html#moveit-tutorials-on-windows","text":"This guide is to show you how to prepare a workspace for MoveIt tutorials. Find out more about MoveIt, visit here .","title":"MoveIt Tutorials on Windows"},{"location":"Moveit/moveit_tutorials.html#moveit-binary-installation-on-windows","text":"Download the ROS on Windows with MoveIt packages. (open an elevated ROS Command Window as described in the installation instructions) Noetic mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-noetic-desktop_full -y --execution-timeout=0 Melodic mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-melodic-moveit -y --execution-timeout=0","title":"MoveIt Binary Installation on Windows"},{"location":"Moveit/moveit_tutorials.html#create-workspace-for-moveit-tutorials","text":"Then, create a workspace and download the example code. (open a command prompt as admin) Noetic : : activate ROS environment c : \\opt\\ros\\noetic\\x64\\setup.bat : : checkout MoveIt tutorial packages mkdir c:\\moveit_ws\\src cd c:\\moveit_ws\\src git clone https://github.com/ros-planning/moveit_tutorials.git -b melodic-devel git clone https://github.com/ros-planning/panda_moveit_config.git -b melodic-devel git clone https://github.com/frankaemika/franka_ros-release -b release/kinetic/franka_description : : build packages cd c:\\moveit_ws catkin_make Melodic : : activate ROS environment c : \\opt\\ros\\melodic\\x64\\setup.bat : : checkout MoveIt tutorial packages mkdir c:\\moveit_ws\\src cd c:\\moveit_ws\\src git clone https://github.com/ros-planning/moveit_tutorials.git -b melodic-devel git clone https://github.com/ros-planning/panda_moveit_config.git -b melodic-devel git clone https://github.com/frankaemika/franka_ros-release -b release/kinetic/franka_description : : build packages cd c:\\moveit_ws catkin_make After it is built, activate the development workspace. c : \\moveit_ws\\devel\\setup.bat","title":"Create Workspace for MoveIt Tutorials"},{"location":"Moveit/moveit_tutorials.html#getting-started-with-moveit-tutorials","text":"Now you are ready to continue to the MoveIt Quickstart in RViz section of the tutorials MoveIt Tutorials .","title":"Getting Started with MoveIt Tutorials"},{"location":"Notes/bond/bond-creation-timeout.html","text":"bond timeout issue nodelet works with the manager-children structure, and bond s are formed between the manager and a child to transmit heartbeat data between the 2. bond is essentially a templated class to create publishers and subscribers for the /<manager>/bond topic. Definitions related to this analysis in the Bond class include: the Bond class defines timers for different purposes. The timer related to this issue is the connect_timer_ variable the Bond class initializes all timers with default timeout values. The default timeout value for connect_timer_ is bond::Constants::DEFAULT_CONNECT_TIMEOUT , which is 10.0 seconds by default the Bond class defines both ros::Subscriber sub_ and ros::Publisher pub_ , which are initialized upon Bond::start() When a nodelet requests the manager to load code, a bond (if requested) will also be attempted to be formed. During this process, the nodelet manager and the child talk in the following steps: child sends /load_nodelet service request to manager manager receives /load_nodelet service request and loads nodelet code manager process creates bond by calling bond->start() , and starts sending out heartbeat periodically child receives (success) response from /load_nodelet service request child process creates bond by calling bond->start() , and starts sending out heartbeat periodically the bond class recognizes a connection between 2 process when its subscriber receives the first heartbeat signal from the other process. when the heartbeat signal takes too long to be received, it will mark the connection as timed out. the following is a typical network log when the bond between a nodelet manager process and the nodelet process after removing the timeout. as we can see, the connection ultimately gets established after more than 10 seconds [ INFO] [1562890405.970666100]: creating bond [ed2a422e-61dc-4904-88df-2f37e511b35d] in manager process [ INFO] [1562890405.994268400]: starting bond [0609a515-48ac-4e2e-8a2c-6fd36ef697ff] in nodelet process [ INFO] [1562890406.975367400]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890406.975669500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890406.975161500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890407.000803900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890406.975161500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890407.101340700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890407.200162600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890407.101267700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890407.974825200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890407.975015000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890407.974730900) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890408.000520200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890407.974730900) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890408.000780400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890408.100311500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890408.000661700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890408.975287600]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890408.975501700]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890408.975150700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890409.000731900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890408.975150700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890409.001049400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890409.101234600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890409.000942500) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890409.974813900]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890409.975078600]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890409.974681600) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890410.001003300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890409.974681600) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890410.001354200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890410.100709100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890410.001208600) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890410.975656500]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890410.975812800]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890410.975562800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890411.000465900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890410.975562800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890411.099975500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890411.200872200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890411.099921700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890411.975869200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890411.976046300]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890411.975763300) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890412.000183100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890411.975763300) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890412.100907600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890412.200875300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890412.100867800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890412.976709700]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890412.976921500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890412.976630700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890413.000973600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890412.976630700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890413.100695900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890413.200892500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890413.100656800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890413.975151300]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890413.975465600]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890413.974932100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890414.000426200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890413.974932100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890414.100246400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890414.201452000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890414.100197000) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890414.976412200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890414.976653500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890414.976246100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890415.000773000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890414.976246100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890415.001125100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890415.100916600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890415.001086300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890415.975091500]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890415.975380900]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890415.974927000) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890416.000446900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890415.974927000) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890416.100609400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890416.200165700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890416.100518600) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890416.974734700]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890416.974915000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890416.974628100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890417.000062700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890416.974628100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890417.100349300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890417.200339600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890417.100282800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890417.977415300]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890417.977700000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890417.977267800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890418.000681500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890417.977267800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890418.000986500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890418.101075300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890418.000944100) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890418.975271900]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890418.999782000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890418.975120700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890419.063147200]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890418.975120700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890419.100688200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890419.100421200]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890419.100563900) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890419.200455000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890419.100563900) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890419.975241800]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890419.975373100]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890419.975075500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890420.000584600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890419.975075500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890420.100615700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890420.100336000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890420.100524300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890420.200336100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890420.100524300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff to simplify the explanation, we use the following aliases for the bonds and their publishers and subscribers: bond [ed2a422e-61dc-4904-88df-2f37e511b35d] created in the manager process as b1 , its publisher as b1-pub and subscriber as b1-sub bond [0609a515-48ac-4e2e-8a2c-6fd36ef697ff] created in the nodelet process as b2 , its publisher as b2-pub and subscriber as b2-sub what we have noticed is that even if b2 (in the child process) has started to send out heartbeat signal (its own subscriber-callbacks are getting called), b1 is not getting any heartbeat callback at all for the first few seconds (around 14 seconds). The log indicates: both bonds have been properly initialized publishers and subscribers of both bonds have also been properly initialized b1-sub is not getting signal from b2-pub b2-sub is getting signal from b1-pub as expected Noticing that b1 with its publisher and subscriber are created earlier than b2 and its publisher and subscriber, we can conclude that b1-pub is created earlier than b2-sub (this is because publisher and subscriber creation code is blocking). Meantime, however, b2-pub is created later than b1-sub . Would this be the reason for the behavior above? Searching online would lead us to this question that has been discussed on answers.ros. The root cause for this is that when a publisher is created later than a subscriber, the subscriber takes a long time to establish a connection with the newly emerged publisher. As explained in the \"Node Environment Variables\" section of this ROS documentation , when a machine has more than one network name this problem starts to emerge. To work around it, use the ROS_IP or ROS_HOSTNAME environment variable to specify a designated connection. The network log proves that it works: [ INFO] [1562890762.216079700]: creating bond [469d6a4a-6f6c-40e9-a35a-05526812d10e] in manager process [ INFO] [1562890763.272645100]: starting bond [260dff49-6afa-47a3-b288-fb560cd53edc] in nodelet process [ INFO] [1562890763.220602400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890763.220870700]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890763.220382500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890764.282294900]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890763.220382500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890764.382758000]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890763.382176600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890764.382646800) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890764.482311800]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890764.382646800) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890764.220152000]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890764.220486600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890764.220003500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890765.282785900]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890764.220003500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890765.382817700]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890764.382367100]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890765.382671600) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890765.482481400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890765.382671600) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890765.221731600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890765.222049500]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890765.221565600) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890766.282347400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890765.221565600) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890766.382124800]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890765.381757300]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890766.381970500) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890766.483556400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890766.381970500) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890766.220679800]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890766.221091400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890766.220478900) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890767.282366100]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890766.220478900) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890767.382669700]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890766.382365400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890767.382425100) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890767.482913600]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890767.382425100) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890767.220318200]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890767.220589500]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890767.220160300) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890768.282961200]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890767.220160300) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890768.383043300]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890767.382516700]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890768.382942700) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890768.483124600]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890768.382942700) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890768.219913400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890768.220194100]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890768.219739700) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890769.283423200]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890768.219739700) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890769.382575200]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890768.382076400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890769.382510900) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890769.481919300]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890769.382510900) 260dff49-6afa-47a3-b288-fb560cd53edc","title":"bond timeout issue"},{"location":"Notes/bond/bond-creation-timeout.html#bond-timeout-issue","text":"nodelet works with the manager-children structure, and bond s are formed between the manager and a child to transmit heartbeat data between the 2. bond is essentially a templated class to create publishers and subscribers for the /<manager>/bond topic. Definitions related to this analysis in the Bond class include: the Bond class defines timers for different purposes. The timer related to this issue is the connect_timer_ variable the Bond class initializes all timers with default timeout values. The default timeout value for connect_timer_ is bond::Constants::DEFAULT_CONNECT_TIMEOUT , which is 10.0 seconds by default the Bond class defines both ros::Subscriber sub_ and ros::Publisher pub_ , which are initialized upon Bond::start() When a nodelet requests the manager to load code, a bond (if requested) will also be attempted to be formed. During this process, the nodelet manager and the child talk in the following steps: child sends /load_nodelet service request to manager manager receives /load_nodelet service request and loads nodelet code manager process creates bond by calling bond->start() , and starts sending out heartbeat periodically child receives (success) response from /load_nodelet service request child process creates bond by calling bond->start() , and starts sending out heartbeat periodically the bond class recognizes a connection between 2 process when its subscriber receives the first heartbeat signal from the other process. when the heartbeat signal takes too long to be received, it will mark the connection as timed out. the following is a typical network log when the bond between a nodelet manager process and the nodelet process after removing the timeout. as we can see, the connection ultimately gets established after more than 10 seconds [ INFO] [1562890405.970666100]: creating bond [ed2a422e-61dc-4904-88df-2f37e511b35d] in manager process [ INFO] [1562890405.994268400]: starting bond [0609a515-48ac-4e2e-8a2c-6fd36ef697ff] in nodelet process [ INFO] [1562890406.975367400]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890406.975669500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890406.975161500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890407.000803900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890406.975161500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890407.101340700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890407.200162600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890407.101267700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890407.974825200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890407.975015000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890407.974730900) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890408.000520200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890407.974730900) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890408.000780400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890408.100311500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890408.000661700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890408.975287600]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890408.975501700]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890408.975150700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890409.000731900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890408.975150700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890409.001049400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890409.101234600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890409.000942500) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890409.974813900]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890409.975078600]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890409.974681600) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890410.001003300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890409.974681600) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890410.001354200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890410.100709100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890410.001208600) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890410.975656500]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890410.975812800]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890410.975562800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890411.000465900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890410.975562800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890411.099975500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890411.200872200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890411.099921700) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890411.975869200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890411.976046300]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890411.975763300) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890412.000183100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890411.975763300) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890412.100907600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890412.200875300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890412.100867800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890412.976709700]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890412.976921500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890412.976630700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890413.000973600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890412.976630700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890413.100695900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890413.200892500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890413.100656800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890413.975151300]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890413.975465600]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890413.974932100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890414.000426200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890413.974932100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890414.100246400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890414.201452000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890414.100197000) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890414.976412200]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890414.976653500]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890414.976246100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890415.000773000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890414.976246100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890415.001125100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890415.100916600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890415.001086300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890415.975091500]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890415.975380900]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890415.974927000) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890416.000446900]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890415.974927000) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890416.100609400]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890416.200165700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890416.100518600) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890416.974734700]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890416.974915000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890416.974628100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890417.000062700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890416.974628100) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890417.100349300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890417.200339600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890417.100282800) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890417.977415300]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890417.977700000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890417.977267800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890418.000681500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890417.977267800) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890418.000986500]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890418.101075300]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890418.000944100) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890418.975271900]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890418.999782000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890418.975120700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890419.063147200]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890418.975120700) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890419.100688200]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890419.100421200]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890419.100563900) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890419.200455000]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890419.100563900) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890419.975241800]: ed2a422e-61dc-4904-88df-2f37e511b35d: heartbeat - 1 [ INFO] [1562890419.975373100]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890419.975075500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890420.000584600]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890419.975075500) ed2a422e-61dc-4904-88df-2f37e511b35d [ INFO] [1562890420.100615700]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: heartbeat - 1 [ INFO] [1562890420.100336000]: ed2a422e-61dc-4904-88df-2f37e511b35d: bond status callback - (1562890420.100524300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff [ INFO] [1562890420.200336100]: 0609a515-48ac-4e2e-8a2c-6fd36ef697ff: bond status callback - (1562890420.100524300) 0609a515-48ac-4e2e-8a2c-6fd36ef697ff to simplify the explanation, we use the following aliases for the bonds and their publishers and subscribers: bond [ed2a422e-61dc-4904-88df-2f37e511b35d] created in the manager process as b1 , its publisher as b1-pub and subscriber as b1-sub bond [0609a515-48ac-4e2e-8a2c-6fd36ef697ff] created in the nodelet process as b2 , its publisher as b2-pub and subscriber as b2-sub what we have noticed is that even if b2 (in the child process) has started to send out heartbeat signal (its own subscriber-callbacks are getting called), b1 is not getting any heartbeat callback at all for the first few seconds (around 14 seconds). The log indicates: both bonds have been properly initialized publishers and subscribers of both bonds have also been properly initialized b1-sub is not getting signal from b2-pub b2-sub is getting signal from b1-pub as expected Noticing that b1 with its publisher and subscriber are created earlier than b2 and its publisher and subscriber, we can conclude that b1-pub is created earlier than b2-sub (this is because publisher and subscriber creation code is blocking). Meantime, however, b2-pub is created later than b1-sub . Would this be the reason for the behavior above? Searching online would lead us to this question that has been discussed on answers.ros. The root cause for this is that when a publisher is created later than a subscriber, the subscriber takes a long time to establish a connection with the newly emerged publisher. As explained in the \"Node Environment Variables\" section of this ROS documentation , when a machine has more than one network name this problem starts to emerge. To work around it, use the ROS_IP or ROS_HOSTNAME environment variable to specify a designated connection. The network log proves that it works: [ INFO] [1562890762.216079700]: creating bond [469d6a4a-6f6c-40e9-a35a-05526812d10e] in manager process [ INFO] [1562890763.272645100]: starting bond [260dff49-6afa-47a3-b288-fb560cd53edc] in nodelet process [ INFO] [1562890763.220602400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890763.220870700]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890763.220382500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890764.282294900]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890763.220382500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890764.382758000]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890763.382176600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890764.382646800) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890764.482311800]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890764.382646800) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890764.220152000]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890764.220486600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890764.220003500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890765.282785900]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890764.220003500) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890765.382817700]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890764.382367100]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890765.382671600) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890765.482481400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890765.382671600) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890765.221731600]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890765.222049500]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890765.221565600) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890766.282347400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890765.221565600) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890766.382124800]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890765.381757300]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890766.381970500) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890766.483556400]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890766.381970500) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890766.220679800]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890766.221091400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890766.220478900) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890767.282366100]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890766.220478900) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890767.382669700]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890766.382365400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890767.382425100) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890767.482913600]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890767.382425100) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890767.220318200]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890767.220589500]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890767.220160300) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890768.282961200]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890767.220160300) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890768.383043300]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890767.382516700]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890768.382942700) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890768.483124600]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890768.382942700) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890768.219913400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: heartbeat - 1 [ INFO] [1562890768.220194100]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890768.219739700) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890769.283423200]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890768.219739700) 469d6a4a-6f6c-40e9-a35a-05526812d10e [ INFO] [1562890769.382575200]: 260dff49-6afa-47a3-b288-fb560cd53edc: heartbeat - 1 [ INFO] [1562890768.382076400]: 469d6a4a-6f6c-40e9-a35a-05526812d10e: bond status callback - (1562890769.382510900) 260dff49-6afa-47a3-b288-fb560cd53edc [ INFO] [1562890769.481919300]: 260dff49-6afa-47a3-b288-fb560cd53edc: bond status callback - (1562890769.382510900) 260dff49-6afa-47a3-b288-fb560cd53edc","title":"bond timeout issue"},{"location":"Notes/rosserial/setup.html","text":"Setup rosserial_arduino with ROS on Windows prerequisite ROS on Windows installation: https://github.com/ms-iot/ROSOnWindows/blob/master/GettingStarted/Setup.md Arduino: https://www.arduino.cc/en/Main/Software note: choose Windows Installer (instead of Windows app) to use Arduino with VS Code ~~ optional: VS Code: https://code.visualstudio.com/~~ ~~ optional: VS Code Arduino plugin: https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.vscode-arduino~~ Install follow ROS on Windows setup instructions to install ROS on Windows binaries (install from source code works too, but might be more complicated) (if ROS on Windows is already installed) use the following choco upgrade command to make sure you have the latest binaries choco upgrade ros-melodic-desktop -y load ROS on Windows environment with setup.bat , similar to the following command C:\\opt\\ros\\melodic\\x64\\setup.bat note: this step is critical; otherwise all the ROS CLI tools like catkin_make or catkin_make_isolated cannot be used before moving on to rosserial installation, check environment you should see this is ROS environment is loaded >set ros ROS_DISTRO=melodic ROS_ETC_DIR=C:/opt/ros/melodic/x64/etc/ros ROS_MASTER_URI=http://localhost:11311 ROS_PACKAGE_PATH=C:\\opt\\ros\\melodic\\x64\\share ROS_PYTHON_VERSION=2 ROS_ROOT=C:/opt/ros/melodic/x64/share/ros ROS_VERSION=1 >set path Path=C:/opt/rosdeps/x64\\bin;C:/opt/rosdeps/x64\\lib;C:/opt/ros/melodic/x64\\bin;C:/opt/ros/melodic/x64\\lib;... you should see this if Python (for ROS) is added to PATH >set path Path=...;C:\\opt\\python27amd64\\;C:\\opt\\python27amd64\\Scripts;... you should be able to use call Python from command line >python --version Python 2.7.15 create rosserial workspace, clone rosserial , and build note: please use ms-iot:init_windows on Windows until ms-iot changes are upstreamed back to ROS mainline mkdir c:\\ros\\catkin_ws\\rosserial\\src\\ && cd c:\\ros\\catkin_ws\\rosserial\\src\\ git clone https://github.com/ms-iot/rosserial.git -b init_windows cd .. catkin_make_isolated load rosserial environment just have just been built, and setup Arduino environment (assuming current work directory is still c:\\ros\\catkin_ws\\rosserial ) note: these steps are very similar to the steps (for Ubuntu) in rosserial_arduino tutorials .\\install_isolated\\setup.bat rosrun rosserial_arduino make_libraries.py . at this point, a new folder called ros_lib should have been generated, copy that to the library folder for Arduino library folder for Arduino could be found through these steps: launch Arduino Open File\\Preferences find Sketchbook location, the path would be <path>\\Arduino Arduino's library path would be <path>\\Arduino\\libraries check if ros_lib is installed correctly for Arduino launch Arduino (close and relaunch if needed) check File\\Examples there sould be ros_lib under Examples from Custom Libraries explore rosserial by following its tutorials note: certain #define flags need to be added for specific platforms, check rosserial_arduino for details - especially, add #define USE_USBCON for Arduino based on 32u4: Leonardo, Micro","title":"Setup `rosserial_arduino` with ROS on Windows"},{"location":"Notes/rosserial/setup.html#setup-rosserial_arduino-with-ros-on-windows","text":"","title":"Setup rosserial_arduino with ROS on Windows"},{"location":"Notes/rosserial/setup.html#prerequisite","text":"ROS on Windows installation: https://github.com/ms-iot/ROSOnWindows/blob/master/GettingStarted/Setup.md Arduino: https://www.arduino.cc/en/Main/Software note: choose Windows Installer (instead of Windows app) to use Arduino with VS Code ~~ optional: VS Code: https://code.visualstudio.com/~~ ~~ optional: VS Code Arduino plugin: https://marketplace.visualstudio.com/items?itemName=vsciot-vscode.vscode-arduino~~","title":"prerequisite"},{"location":"Notes/rosserial/setup.html#install","text":"follow ROS on Windows setup instructions to install ROS on Windows binaries (install from source code works too, but might be more complicated) (if ROS on Windows is already installed) use the following choco upgrade command to make sure you have the latest binaries choco upgrade ros-melodic-desktop -y load ROS on Windows environment with setup.bat , similar to the following command C:\\opt\\ros\\melodic\\x64\\setup.bat note: this step is critical; otherwise all the ROS CLI tools like catkin_make or catkin_make_isolated cannot be used before moving on to rosserial installation, check environment you should see this is ROS environment is loaded >set ros ROS_DISTRO=melodic ROS_ETC_DIR=C:/opt/ros/melodic/x64/etc/ros ROS_MASTER_URI=http://localhost:11311 ROS_PACKAGE_PATH=C:\\opt\\ros\\melodic\\x64\\share ROS_PYTHON_VERSION=2 ROS_ROOT=C:/opt/ros/melodic/x64/share/ros ROS_VERSION=1 >set path Path=C:/opt/rosdeps/x64\\bin;C:/opt/rosdeps/x64\\lib;C:/opt/ros/melodic/x64\\bin;C:/opt/ros/melodic/x64\\lib;... you should see this if Python (for ROS) is added to PATH >set path Path=...;C:\\opt\\python27amd64\\;C:\\opt\\python27amd64\\Scripts;... you should be able to use call Python from command line >python --version Python 2.7.15 create rosserial workspace, clone rosserial , and build note: please use ms-iot:init_windows on Windows until ms-iot changes are upstreamed back to ROS mainline mkdir c:\\ros\\catkin_ws\\rosserial\\src\\ && cd c:\\ros\\catkin_ws\\rosserial\\src\\ git clone https://github.com/ms-iot/rosserial.git -b init_windows cd .. catkin_make_isolated load rosserial environment just have just been built, and setup Arduino environment (assuming current work directory is still c:\\ros\\catkin_ws\\rosserial ) note: these steps are very similar to the steps (for Ubuntu) in rosserial_arduino tutorials .\\install_isolated\\setup.bat rosrun rosserial_arduino make_libraries.py . at this point, a new folder called ros_lib should have been generated, copy that to the library folder for Arduino library folder for Arduino could be found through these steps: launch Arduino Open File\\Preferences find Sketchbook location, the path would be <path>\\Arduino Arduino's library path would be <path>\\Arduino\\libraries check if ros_lib is installed correctly for Arduino launch Arduino (close and relaunch if needed) check File\\Examples there sould be ros_lib under Examples from Custom Libraries explore rosserial by following its tutorials note: certain #define flags need to be added for specific platforms, check rosserial_arduino for details - especially, add #define USE_USBCON for Arduino based on 32u4: Leonardo, Micro","title":"Install"},{"location":"Porting/Cookbook.html","text":"ROS for Windows Porting Cookbook While every effort has been made to reduce the effort needed to support ROS nodes on Windows, there will inevitably be required changes between platforms. This cookbook is intended to collect common issues and recommended solutions. Windows and Linux Differences Directory Separators Windows uses backslash \\ whereas Linux uses forward slash / . As we encounter path processing, we've been replacing them with the Python or Boost equivelents. User directory Linux has a neat shortcut for refering to the users' home directory ~ . Windows uses the environment variable %USERPROFILE% - use this whenever you see ~ in ROS documentation. Quote handling in command window Cmd.exe is the command processor of command window. Single quotes are not used at all by the cmd.exe except in batch file to enclose the command to run within a FOR /F statement. Cmd.exe handles quoting with double quotes. This is different from Linux that uses single quote as quote character. As encounter quoting on Windows, please use double quote. The following example shows using double quotes around the message contents: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- \"[2.0, 0.0, 0.0]\" \"[0.0, 0.0, 1.8]\" Paths and ROS commands Many ROS Commands are sensitive to the drive letter they are executed from. This manifests in problems such as rosdeps not resolving correctly. To address this either: * Put all of your ROS workspaces on the C:\\ drive * Link folders from your C:\\ drive to your workspaces. To link a folder on Windows, use the mklink to create a filesystem link from one drive to another.: mkdir d:\\workspaces mklink c:\\workspaces d:\\workspaces Symbol Visibility Windows and Linux handle symbol visibility differently. You may encounter a build error of the form: error C2448: '__attribute__': function-style initializer appears to be a function definition 'visibility': identifier not found The GCC visibility documentation \u2197 has a good article on handling the compiler differences. This includes adding a header file which uses a compiler switch to select the correct visibility macro handler. Symbol Visibility also impacts binary loading. If you are finding a Nodelet that does not run or a Qt Visualizer isn't working, it may be that the hosting process can not find an expected binary export. To diagnose this on Windows, the Windows developer tools includes a program called Gflags to enable various options. One of those options is called Loader Snaps which enables you to detect load failures while debugging. Please visit the Microsoft Documentation for more information on Gflags and Loaders snaps . install Library TARGETS given no DESTINATION! Windows will generate separate archives and librarys. To handle this, add an ARCHIVE destination: install( TARGETS ${PROJECT_NAME} ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}) All Warnings Warnings are good. The options for selecting warning level are different. If you add specific compiler options for warnings, please add an MSVC selection. For the Visual Studio compiler, you'll use /W3 for warning level 3 (or /W4 which offers more warning options). If you would like to treat warnings as errors pass /WX . However, these warnings would need to be corrected before the compile will succeed. if (MSVC) add_compile_options(/W3 /WX) else() add_compile_options(-Wall -Wextra) endif() You can disable specific warnings using #pragma : #ifdef _MSC_VER #pragma warning(disable: 4244) #pragma warning(disable: 4661) #endif Security Warnings Windows deprecates certain C APIs because they are inherently insecure. You will receive a message of the form: warning C4996: 'xxx': This function or variable may be unsafe. Consider using xxx_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. Consider using modern equivelents. If you cannot use a modern equivelent, you can add the following to your cmake files: add_definitions( \"/D_CRT_SECURE_NO_WARNINGS\" ) add_definitions( \"/D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\" ) C++ versioning Use CMake to set the C++ version: if (NOT CMAKE_CXX_STANDARD) set (CMAKE_CXX_STANDARD 11) endif() or if (NOT CMAKE_CXX_STANDARD) set (CMAKE_CXX_STANDARD 17) endif() NOTE: Boost 1.66 in the Melodic requires CMAKE_CXX_STANDARD 11 __attribute____ __attribute__ is not suppported with Microsoft compilers. You can use a macro replacement or use a cross platform convention. Unresolved External Linux automatically exports symbols. Windows, symbols are private by default. CMake provides a facility for this . In your cmake: set (CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON) However, you may encounter a problem with static class members, i.e. global data symbols, as discussed in https://blog.kitware.com/create-dlls-on-windows-without-declspec-using-new-cmake-export-all-feature/. In this case you need to manually handle visibility of the static class members, using the GenerateExportHeader CMake module. In particular, if your static class members are contained in a library called mylibrary , you need to add the following lines in your CMake after the call to add_library(mylibrary ...) : include(GenerateExportHeader) generate_export_header(mylibrary) target_include_directories(mylibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR}) The generate_export_header(mylibrary) call creates a file called mylibrary_export.h , contained in the ${CMAKE_CURRENT_BINARY_DIR} build directory. This file contains the definition of the mylibrary_EXPORT macro, that you can use to modify your code as in the following: #include \"mylibrary_export.h\" class myclass { static MYLIBRARY_EXPORT int GlobalCounter; \u2026 If this class definition is contained in a public header, you need to make sure to install the generated mylibrary_export.h together with the rest of the headers, i.e. : install(FILES ${CMAKE_CURRENT_BINARY_DIR}/mylibrary_export.h DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION}) Beware of aggressive optimization The Microsoft compiler will optimize agressively. This can manifest in strange ways. One instance was in turtlebot3 fake code, is a ROS_ASSERT with a function that only returns true. Nothing else executed. Case sensitivity Linux is case sensitive, whereas Windows is not. We are trying to locate case sensitive areas and isolate them. This manifests in odd errors like this: RLException: multiple files named [turtlebot3_robot.launch] in package [turtlebot3_bringup]: - C:\\ws\\turtlebot_ws\\install\\share\\turtlebot3_bringup\\launch\\turtlebot3_robot.launch - c:\\ws\\turtlebot_ws\\install\\share\\turtlebot3_bringup\\launch\\turtlebot3_robot.launch In this case, the ROS_PACKAGE_PATH has a lower case drive letter. Python Shebang Windows does not support Shebang character sequence for automatically launching an interpreter. To support Python nodes on Windows, a few changes need to be made. Shebang in ROS nodes If a ROS node uses Python, please rename the file with the .py extension. Shebang in command line commands If you are producing a command line application which will be installed with Pip, please add a windows wrapper. Errors gtest-NOTFOUND This occurs when linking against gtest instead of ${GTEST_LIBRARIES} target_link_libraries( rtest ${GTEST_LIBRARIES} ${catkin_LIBRARIES} ) Syntax error: 'constant' (windows.h included before conflicting dependency) Cause: Windows.h defines some macros which may conflict with variables defined in ROS packages. This causes build breaks if windows.h is included before a conflicting dependency. The error for this may be misleading as it may not identify the specific redeclaration as the issue. Example: C:\\ws_moveit\\src\\moveit_tutorials\\doc\\perception_pipeline\\src\\cylinder_segment.cpp In this file in the MoveIt tutorials, a file which included the window.h header (pcl) was included before a file which included (marker.h via planning_scene_interface.h). This is problematic because marker.h defines DELETE as an enum member while DELETE is also defined as a macro in windows.h . In this case the build error was: C:\\opt\\ros\\melodic\\x64\\include\\visualization_msgs/Marker.h(132): error C2059: syntax error: 'constant' Fix: Include any headers which define the conflicting variable (i.e. DELETE ) above/before any headers which include windows.h . Missing Symbols 'M_PI' Add the following to the top of your file: #define _USE_MATH_DEFINES or define it in the CMakeFile.exe Warnings The Microsoft Visual Studio compiler has strict type checking enabled by default. Here are some common warnings. Truncation '=': truncation from 'double' to float Use appropriate casts ensuring accuracy of the conversion. unreferenced parameters Either remove the variable, or reference it in a noop block uint8_t unused ; unused ; CMAKE_C_COMPILER or CMAKE_CXX_COMPILER error When Visual Studio upgrades, it changes the path to the compilers. If you have previously built a ROS workspace, you'll see an error like this: CMake Error in CMakeLists.txt: The CMAKE_CXX_COMPILER: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.22.27905/bin/Hostx64/x64/cl.exe Cause This is caused by a stale CMake cache. Fix Remove the build, devel and install directories and rebuild. CMake Tip - verbose output When debugging a build failure, it is sometimes helpful to have verbose logging enabled: catkin_make -DCMAKE_VERBOSE_MAKEFILE=ON Start ROS on Boot Once you are done developing your robot and want it to automatically start on boot, you'll want to use the Windows Task Scheduler to start the task. Create a Windows command file, which includes the ROS environment and Install environment, c:\\catkin_ws\\start_ros.bat call c:\\opt\\ros\\melodic\\x64\\setup.bat call c:\\catkin_ws\\install\\setup.bat roslaunch <package> <launch file> * Use the command Schtasks , to add a task which calls this script: schtasks /Create /RU <User> /RP <password> /SC ONLOGON /TN ROS /TR \"c:\\catkin_ws\\start_ros.bat\" Enable Windows Auto logon Use the Autologon documentation at Microsoft's Support website to conigure autologon. Alternatively use the Autologon Sysinternals tool to configure autologon from the command line. The next time the system starts, the ROS task will run.","title":"Porting Cookbook"},{"location":"Porting/Cookbook.html#ros-for-windows-porting-cookbook","text":"While every effort has been made to reduce the effort needed to support ROS nodes on Windows, there will inevitably be required changes between platforms. This cookbook is intended to collect common issues and recommended solutions.","title":"ROS for Windows Porting Cookbook"},{"location":"Porting/Cookbook.html#windows-and-linux-differences","text":"","title":"Windows and Linux Differences"},{"location":"Porting/Cookbook.html#directory-separators","text":"Windows uses backslash \\ whereas Linux uses forward slash / . As we encounter path processing, we've been replacing them with the Python or Boost equivelents.","title":"Directory Separators"},{"location":"Porting/Cookbook.html#user-directory","text":"Linux has a neat shortcut for refering to the users' home directory ~ . Windows uses the environment variable %USERPROFILE% - use this whenever you see ~ in ROS documentation.","title":"User directory"},{"location":"Porting/Cookbook.html#quote-handling-in-command-window","text":"Cmd.exe is the command processor of command window. Single quotes are not used at all by the cmd.exe except in batch file to enclose the command to run within a FOR /F statement. Cmd.exe handles quoting with double quotes. This is different from Linux that uses single quote as quote character. As encounter quoting on Windows, please use double quote. The following example shows using double quotes around the message contents: rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- \"[2.0, 0.0, 0.0]\" \"[0.0, 0.0, 1.8]\"","title":"Quote handling in command window"},{"location":"Porting/Cookbook.html#paths-and-ros-commands","text":"Many ROS Commands are sensitive to the drive letter they are executed from. This manifests in problems such as rosdeps not resolving correctly. To address this either: * Put all of your ROS workspaces on the C:\\ drive * Link folders from your C:\\ drive to your workspaces. To link a folder on Windows, use the mklink to create a filesystem link from one drive to another.: mkdir d:\\workspaces mklink c:\\workspaces d:\\workspaces","title":"Paths and ROS commands"},{"location":"Porting/Cookbook.html#symbol-visibility","text":"Windows and Linux handle symbol visibility differently. You may encounter a build error of the form: error C2448: '__attribute__': function-style initializer appears to be a function definition 'visibility': identifier not found The GCC visibility documentation \u2197 has a good article on handling the compiler differences. This includes adding a header file which uses a compiler switch to select the correct visibility macro handler. Symbol Visibility also impacts binary loading. If you are finding a Nodelet that does not run or a Qt Visualizer isn't working, it may be that the hosting process can not find an expected binary export. To diagnose this on Windows, the Windows developer tools includes a program called Gflags to enable various options. One of those options is called Loader Snaps which enables you to detect load failures while debugging. Please visit the Microsoft Documentation for more information on Gflags and Loaders snaps .","title":"Symbol Visibility"},{"location":"Porting/Cookbook.html#install-library-targets-given-no-destination","text":"Windows will generate separate archives and librarys. To handle this, add an ARCHIVE destination: install( TARGETS ${PROJECT_NAME} ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION})","title":"install Library TARGETS given no DESTINATION!"},{"location":"Porting/Cookbook.html#all-warnings","text":"Warnings are good. The options for selecting warning level are different. If you add specific compiler options for warnings, please add an MSVC selection. For the Visual Studio compiler, you'll use /W3 for warning level 3 (or /W4 which offers more warning options). If you would like to treat warnings as errors pass /WX . However, these warnings would need to be corrected before the compile will succeed. if (MSVC) add_compile_options(/W3 /WX) else() add_compile_options(-Wall -Wextra) endif() You can disable specific warnings using #pragma : #ifdef _MSC_VER #pragma warning(disable: 4244) #pragma warning(disable: 4661) #endif","title":"All Warnings"},{"location":"Porting/Cookbook.html#security-warnings","text":"Windows deprecates certain C APIs because they are inherently insecure. You will receive a message of the form: warning C4996: 'xxx': This function or variable may be unsafe. Consider using xxx_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. Consider using modern equivelents. If you cannot use a modern equivelent, you can add the following to your cmake files: add_definitions( \"/D_CRT_SECURE_NO_WARNINGS\" ) add_definitions( \"/D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS\" )","title":"Security Warnings"},{"location":"Porting/Cookbook.html#c-versioning","text":"Use CMake to set the C++ version: if (NOT CMAKE_CXX_STANDARD) set (CMAKE_CXX_STANDARD 11) endif() or if (NOT CMAKE_CXX_STANDARD) set (CMAKE_CXX_STANDARD 17) endif() NOTE: Boost 1.66 in the Melodic requires CMAKE_CXX_STANDARD 11","title":"C++ versioning"},{"location":"Porting/Cookbook.html#__attribute____","text":"__attribute__ is not suppported with Microsoft compilers. You can use a macro replacement or use a cross platform convention.","title":"__attribute____"},{"location":"Porting/Cookbook.html#unresolved-external","text":"Linux automatically exports symbols. Windows, symbols are private by default. CMake provides a facility for this . In your cmake: set (CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON) However, you may encounter a problem with static class members, i.e. global data symbols, as discussed in https://blog.kitware.com/create-dlls-on-windows-without-declspec-using-new-cmake-export-all-feature/. In this case you need to manually handle visibility of the static class members, using the GenerateExportHeader CMake module. In particular, if your static class members are contained in a library called mylibrary , you need to add the following lines in your CMake after the call to add_library(mylibrary ...) : include(GenerateExportHeader) generate_export_header(mylibrary) target_include_directories(mylibrary PRIVATE ${CMAKE_CURRENT_BINARY_DIR}) The generate_export_header(mylibrary) call creates a file called mylibrary_export.h , contained in the ${CMAKE_CURRENT_BINARY_DIR} build directory. This file contains the definition of the mylibrary_EXPORT macro, that you can use to modify your code as in the following: #include \"mylibrary_export.h\" class myclass { static MYLIBRARY_EXPORT int GlobalCounter; \u2026 If this class definition is contained in a public header, you need to make sure to install the generated mylibrary_export.h together with the rest of the headers, i.e. : install(FILES ${CMAKE_CURRENT_BINARY_DIR}/mylibrary_export.h DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION})","title":"Unresolved External"},{"location":"Porting/Cookbook.html#beware-of-aggressive-optimization","text":"The Microsoft compiler will optimize agressively. This can manifest in strange ways. One instance was in turtlebot3 fake code, is a ROS_ASSERT with a function that only returns true. Nothing else executed.","title":"Beware of aggressive optimization"},{"location":"Porting/Cookbook.html#case-sensitivity","text":"Linux is case sensitive, whereas Windows is not. We are trying to locate case sensitive areas and isolate them. This manifests in odd errors like this: RLException: multiple files named [turtlebot3_robot.launch] in package [turtlebot3_bringup]: - C:\\ws\\turtlebot_ws\\install\\share\\turtlebot3_bringup\\launch\\turtlebot3_robot.launch - c:\\ws\\turtlebot_ws\\install\\share\\turtlebot3_bringup\\launch\\turtlebot3_robot.launch In this case, the ROS_PACKAGE_PATH has a lower case drive letter.","title":"Case sensitivity"},{"location":"Porting/Cookbook.html#python","text":"","title":"Python"},{"location":"Porting/Cookbook.html#shebang","text":"Windows does not support Shebang character sequence for automatically launching an interpreter. To support Python nodes on Windows, a few changes need to be made.","title":"Shebang"},{"location":"Porting/Cookbook.html#shebang-in-ros-nodes","text":"If a ROS node uses Python, please rename the file with the .py extension.","title":"Shebang in ROS nodes"},{"location":"Porting/Cookbook.html#shebang-in-command-line-commands","text":"If you are producing a command line application which will be installed with Pip, please add a windows wrapper.","title":"Shebang in command line commands"},{"location":"Porting/Cookbook.html#errors","text":"","title":"Errors"},{"location":"Porting/Cookbook.html#gtest-notfound","text":"This occurs when linking against gtest instead of ${GTEST_LIBRARIES} target_link_libraries( rtest ${GTEST_LIBRARIES} ${catkin_LIBRARIES} )","title":"gtest-NOTFOUND"},{"location":"Porting/Cookbook.html#syntax-error-constant-windowsh-included-before-conflicting-dependency","text":"","title":"Syntax error: 'constant' (windows.h included before conflicting dependency)"},{"location":"Porting/Cookbook.html#cause","text":"Windows.h defines some macros which may conflict with variables defined in ROS packages. This causes build breaks if windows.h is included before a conflicting dependency. The error for this may be misleading as it may not identify the specific redeclaration as the issue.","title":"Cause:"},{"location":"Porting/Cookbook.html#example","text":"C:\\ws_moveit\\src\\moveit_tutorials\\doc\\perception_pipeline\\src\\cylinder_segment.cpp In this file in the MoveIt tutorials, a file which included the window.h header (pcl) was included before a file which included (marker.h via planning_scene_interface.h). This is problematic because marker.h defines DELETE as an enum member while DELETE is also defined as a macro in windows.h . In this case the build error was: C:\\opt\\ros\\melodic\\x64\\include\\visualization_msgs/Marker.h(132): error C2059: syntax error: 'constant'","title":"Example:"},{"location":"Porting/Cookbook.html#fix","text":"Include any headers which define the conflicting variable (i.e. DELETE ) above/before any headers which include windows.h .","title":"Fix:"},{"location":"Porting/Cookbook.html#missing-symbols","text":"","title":"Missing Symbols"},{"location":"Porting/Cookbook.html#m_pi","text":"Add the following to the top of your file: #define _USE_MATH_DEFINES or define it in the CMakeFile.exe","title":"'M_PI'"},{"location":"Porting/Cookbook.html#warnings","text":"The Microsoft Visual Studio compiler has strict type checking enabled by default. Here are some common warnings.","title":"Warnings"},{"location":"Porting/Cookbook.html#truncation","text":"'=': truncation from 'double' to float Use appropriate casts ensuring accuracy of the conversion.","title":"Truncation"},{"location":"Porting/Cookbook.html#unreferenced-parameters","text":"Either remove the variable, or reference it in a noop block uint8_t unused ; unused ;","title":"unreferenced parameters"},{"location":"Porting/Cookbook.html#cmake_c_compiler-or-cmake_cxx_compiler-error","text":"When Visual Studio upgrades, it changes the path to the compilers. If you have previously built a ROS workspace, you'll see an error like this: CMake Error in CMakeLists.txt: The CMAKE_CXX_COMPILER: C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC/Tools/MSVC/14.22.27905/bin/Hostx64/x64/cl.exe","title":"CMAKE_C_COMPILER or CMAKE_CXX_COMPILER error"},{"location":"Porting/Cookbook.html#cause_1","text":"This is caused by a stale CMake cache.","title":"Cause"},{"location":"Porting/Cookbook.html#fix_1","text":"Remove the build, devel and install directories and rebuild.","title":"Fix"},{"location":"Porting/Cookbook.html#cmake-tip-verbose-output","text":"When debugging a build failure, it is sometimes helpful to have verbose logging enabled: catkin_make -DCMAKE_VERBOSE_MAKEFILE=ON","title":"CMake Tip - verbose output"},{"location":"Porting/Cookbook.html#start-ros-on-boot","text":"Once you are done developing your robot and want it to automatically start on boot, you'll want to use the Windows Task Scheduler to start the task. Create a Windows command file, which includes the ROS environment and Install environment, c:\\catkin_ws\\start_ros.bat call c:\\opt\\ros\\melodic\\x64\\setup.bat call c:\\catkin_ws\\install\\setup.bat roslaunch <package> <launch file> * Use the command Schtasks , to add a task which calls this script: schtasks /Create /RU <User> /RP <password> /SC ONLOGON /TN ROS /TR \"c:\\catkin_ws\\start_ros.bat\" Enable Windows Auto logon Use the Autologon documentation at Microsoft's Support website to conigure autologon. Alternatively use the Autologon Sysinternals tool to configure autologon from the command line. The next time the system starts, the ROS task will run.","title":"Start ROS on Boot"},{"location":"Porting/PortingStatus.html","text":"Porting Status This page covers the current porting status of ROS1 on Windows. Plan Microsoft has been working with Open Robotics and ROS Industrial Consortium on the ROS for Windows porting logistics. Open Robotics has provided a list (below) of packages which need to be ported in order to not be considered experimental. Once tested and upstreamed, Open Robotics will consider Windows supported. We are targeting Mid-December to complete the ROS porting effort. October 2018 rViz Missing panels appear to be a timing issue which also repros on Linux. MoveIt First Life! We have MoveIt planning paths for a UR-3. Developing a program to close the loop with customers Navigation Workin on Cartographer port Working on other ports Started discussions about upstreaming. September 2018 Core ROS Core ROS has been ported ROSSerial We are observing some transport failures in the ROSSerial connection. rViz Subpanels, such as Display, do not show up consistently. We believe it is an optimization problem. We're working on this. Gazebo Port has not started Yet. This is a long port, which will start after MoveIt for Windows is completed. Turtlebot3 Turtlebot mostly brought up. Navigation in progress Perception Camera nodes Lidar OpenNI porting started. Navigation OpenKarto has been ported, but not tested. gmapping port has not started We will discuss other mapping projects with their maintainers MoveIt MoveIt port started Linux testing ROSComm in progress ROS# Testing has not started, but we believe it will work Packages to port Top 40 [X] python-catkin-pkg [X] python-catkin-pkg-modules [X] python-rosdep [X] python-rosdistro [X] python-rosdistro-modules [X] python-rospkg [X] python-rospkg-modules [X] ros-melodic-actionlib [X] ros-melodic-actionlib-msgs [X] ros-melodic-cv-bridge [X] ros-melodic-desktop [X] ros-melodic-desktop-full [X] ros-melodic-diagnostic-updater [X] ros-melodic-gazebo-plugins [X] ros-melodic-gazebo-ros [X] ros-melodic-geometry-msgs [X] ros-melodic-image-transport [X] ros-melodic-interactive-markers [X] ros-melodic-kdl-parser [X] ros-melodic-laser-geometry [X] ros-melodic-nav-msgs [X] ros-melodic-pcl-conversions [X] ros-melodic-pcl-msgs [X] ros-melodic-pcl-ros [X] ros-melodic-robot-state-publisher [X] ros-melodic-rqt-robot-plugins [X] ros-melodic-rqt-rviz [X] ros-melodic-rviz [X] ros-melodic-sensor-msgs [X] ros-melodic-simulators [X] ros-melodic-tf [X] ros-melodic-tf2 [X] ros-melodic-tf2-eigen [X] ros-melodic-tf2-geometry-msgs [X] ros-melodic-tf2-kdl [X] ros-melodic-tf2-msgs [X] ros-melodic-tf2-py [X] ros-melodic-tf2-ros [X] ros-melodic-tf-conversions [X] ros-melodic-viz","title":"Porting Status"},{"location":"Porting/PortingStatus.html#porting-status","text":"This page covers the current porting status of ROS1 on Windows.","title":"Porting Status"},{"location":"Porting/PortingStatus.html#plan","text":"Microsoft has been working with Open Robotics and ROS Industrial Consortium on the ROS for Windows porting logistics. Open Robotics has provided a list (below) of packages which need to be ported in order to not be considered experimental. Once tested and upstreamed, Open Robotics will consider Windows supported. We are targeting Mid-December to complete the ROS porting effort.","title":"Plan"},{"location":"Porting/PortingStatus.html#october-2018","text":"rViz Missing panels appear to be a timing issue which also repros on Linux. MoveIt First Life! We have MoveIt planning paths for a UR-3. Developing a program to close the loop with customers Navigation Workin on Cartographer port Working on other ports Started discussions about upstreaming.","title":"October 2018"},{"location":"Porting/PortingStatus.html#september-2018","text":"Core ROS Core ROS has been ported ROSSerial We are observing some transport failures in the ROSSerial connection. rViz Subpanels, such as Display, do not show up consistently. We believe it is an optimization problem. We're working on this. Gazebo Port has not started Yet. This is a long port, which will start after MoveIt for Windows is completed. Turtlebot3 Turtlebot mostly brought up. Navigation in progress Perception Camera nodes Lidar OpenNI porting started. Navigation OpenKarto has been ported, but not tested. gmapping port has not started We will discuss other mapping projects with their maintainers MoveIt MoveIt port started Linux testing ROSComm in progress ROS# Testing has not started, but we believe it will work","title":"September 2018"},{"location":"Porting/PortingStatus.html#packages-to-port","text":"Top 40 [X] python-catkin-pkg [X] python-catkin-pkg-modules [X] python-rosdep [X] python-rosdistro [X] python-rosdistro-modules [X] python-rospkg [X] python-rospkg-modules [X] ros-melodic-actionlib [X] ros-melodic-actionlib-msgs [X] ros-melodic-cv-bridge [X] ros-melodic-desktop [X] ros-melodic-desktop-full [X] ros-melodic-diagnostic-updater [X] ros-melodic-gazebo-plugins [X] ros-melodic-gazebo-ros [X] ros-melodic-geometry-msgs [X] ros-melodic-image-transport [X] ros-melodic-interactive-markers [X] ros-melodic-kdl-parser [X] ros-melodic-laser-geometry [X] ros-melodic-nav-msgs [X] ros-melodic-pcl-conversions [X] ros-melodic-pcl-msgs [X] ros-melodic-pcl-ros [X] ros-melodic-robot-state-publisher [X] ros-melodic-rqt-robot-plugins [X] ros-melodic-rqt-rviz [X] ros-melodic-rviz [X] ros-melodic-sensor-msgs [X] ros-melodic-simulators [X] ros-melodic-tf [X] ros-melodic-tf2 [X] ros-melodic-tf2-eigen [X] ros-melodic-tf2-geometry-msgs [X] ros-melodic-tf2-kdl [X] ros-melodic-tf2-msgs [X] ros-melodic-tf2-py [X] ros-melodic-tf2-ros [X] ros-melodic-tf-conversions [X] ros-melodic-viz","title":"Packages to port"},{"location":"Porting/ms-iot_payload.html","text":"ms-iot payloads for ROS on Windows packages List of repos redirected in rosdistro-db (ms-iot) : TODO: remove redirection to ms-iot repos without change all repos in init_windows branch unless specified * https://github.com/ms-iot/abseil-cpp.git * https://github.com/ms-iot/diagnostics.git * https://github.com/ms-iot/filters.git * https://github.com/ms-iot/gazebo_ros_pkgs.git * https://github.com/ms-iot/geometry.git * https://github.com/ms-iot/geometry2.git * https://github.com/ms-iot/image_common.git * https://github.com/ms-iot/industrial_core.git * https://github.com/ms-iot/interactive_markers.git * https://github.com/ms-iot/joystick_drivers.git * https://github.com/ms-iot/moveit.git * https://github.com/ms-iot/navigation.git * https://github.com/ms-iot/pluginlib.git * https://github.com/ms-iot/ros_comm.git * https://github.com/ms-iot/ros_environment.git * https://github.com/ms-iot/ros_tutorials.git * https://github.com/ms-iot/ros_type_introspection.git * https://github.com/ms-iot/rosserial.git * https://github.com/ms-iot/slam_karto.git * https://github.com/ms-iot/sparse_bundle_adjustment.git * https://github.com/ms-iot/stage-release.git * https://github.com/ms-iot/stage_ros.git * https://github.com/ms-iot/universal_robot.git * https://github.com/ms-iot/urdf.git * https://github.com/ms-iot/vision_opencv.git * https://github.com/ms-iot/descartes list of init_windows repos for current porting task with cached commits: 1st Tier Changes Packages in ros-melodic-ros_base . ros * ~~ms-iot/rosdistro-db~~ ros-infrastructure * ms-iot/rosdep * ms-iot/wstool * ms-iot/vcstools ros_core * ms-iot/pluginlib * ms-iot/ros_comm * ms-iot/ros_environment 2nd Tier Changes Packages beyond ros-melodic-ros_base , within ros-melodic-desktop_full . ros * ms-iot/diagnostics , need to merge https://github.com/ros/diagnostics/pull/96 after * ~~ms-iot/filters~~ * ms-iot/geometry * ms-iot/urdf * ms-iot/geometry2 * ms-iot/ros_tutorials ros-perception * ms-iot/image_common * ms-iot/vision_opencv ros-visualization * ms-iot/interactive_markers ros-simulation * ms-iot/gazebo_ros_pkgs * ~~ms-iot/stage_ros~~ * dependency * ~~ms-iot/stage-release~~ ros-planning * ms-iot/navigation 3rd Tier Changes Packages beyond ros-melodic-destkop_full . moveit * ms-iot/moveit universal_robot * ms-iot/universal_robot ros_type_introspection * ms-iot/ros_type_introspection * dependency * ms-iot/abseil-cpp others * ms-iot/industrial_core * ms-iot/joystick_drivers * ms-iot/rosserial * ~~ms-iot/slam_karto~~ * ms-iot/sparse_bundle_adjustment * ms-iot/descartes Other informations The progress of upstream is tracked under projects . Open pull requests from MSFT contributors pull requests from @johnsonshih pull requests from @kejxu pull requests from @seanyen","title":"ms-iot payloads for ROS on Windows packages"},{"location":"Porting/ms-iot_payload.html#ms-iot-payloads-for-ros-on-windows-packages","text":"","title":"ms-iot payloads for ROS on Windows packages"},{"location":"Porting/ms-iot_payload.html#list-of-repos-redirected-in-rosdistro-db-ms-iot","text":"TODO: remove redirection to ms-iot repos without change all repos in init_windows branch unless specified * https://github.com/ms-iot/abseil-cpp.git * https://github.com/ms-iot/diagnostics.git * https://github.com/ms-iot/filters.git * https://github.com/ms-iot/gazebo_ros_pkgs.git * https://github.com/ms-iot/geometry.git * https://github.com/ms-iot/geometry2.git * https://github.com/ms-iot/image_common.git * https://github.com/ms-iot/industrial_core.git * https://github.com/ms-iot/interactive_markers.git * https://github.com/ms-iot/joystick_drivers.git * https://github.com/ms-iot/moveit.git * https://github.com/ms-iot/navigation.git * https://github.com/ms-iot/pluginlib.git * https://github.com/ms-iot/ros_comm.git * https://github.com/ms-iot/ros_environment.git * https://github.com/ms-iot/ros_tutorials.git * https://github.com/ms-iot/ros_type_introspection.git * https://github.com/ms-iot/rosserial.git * https://github.com/ms-iot/slam_karto.git * https://github.com/ms-iot/sparse_bundle_adjustment.git * https://github.com/ms-iot/stage-release.git * https://github.com/ms-iot/stage_ros.git * https://github.com/ms-iot/universal_robot.git * https://github.com/ms-iot/urdf.git * https://github.com/ms-iot/vision_opencv.git * https://github.com/ms-iot/descartes","title":"List of repos redirected in rosdistro-db (ms-iot):"},{"location":"Porting/ms-iot_payload.html#list-of-init_windows-repos-for-current-porting-task-with-cached-commits","text":"","title":"list of init_windows repos for current porting task with cached commits:"},{"location":"Porting/ms-iot_payload.html#1st-tier-changes","text":"Packages in ros-melodic-ros_base . ros * ~~ms-iot/rosdistro-db~~ ros-infrastructure * ms-iot/rosdep * ms-iot/wstool * ms-iot/vcstools ros_core * ms-iot/pluginlib * ms-iot/ros_comm * ms-iot/ros_environment","title":"1st Tier Changes"},{"location":"Porting/ms-iot_payload.html#2nd-tier-changes","text":"Packages beyond ros-melodic-ros_base , within ros-melodic-desktop_full . ros * ms-iot/diagnostics , need to merge https://github.com/ros/diagnostics/pull/96 after * ~~ms-iot/filters~~ * ms-iot/geometry * ms-iot/urdf * ms-iot/geometry2 * ms-iot/ros_tutorials ros-perception * ms-iot/image_common * ms-iot/vision_opencv ros-visualization * ms-iot/interactive_markers ros-simulation * ms-iot/gazebo_ros_pkgs * ~~ms-iot/stage_ros~~ * dependency * ~~ms-iot/stage-release~~ ros-planning * ms-iot/navigation","title":"2nd Tier Changes"},{"location":"Porting/ms-iot_payload.html#3rd-tier-changes","text":"Packages beyond ros-melodic-destkop_full . moveit * ms-iot/moveit universal_robot * ms-iot/universal_robot ros_type_introspection * ms-iot/ros_type_introspection * dependency * ms-iot/abseil-cpp others * ms-iot/industrial_core * ms-iot/joystick_drivers * ms-iot/rosserial * ~~ms-iot/slam_karto~~ * ms-iot/sparse_bundle_adjustment * ms-iot/descartes","title":"3rd Tier Changes"},{"location":"Porting/ms-iot_payload.html#other-informations","text":"The progress of upstream is tracked under projects .","title":"Other informations"},{"location":"Porting/ms-iot_payload.html#open-pull-requests-from-msft-contributors","text":"pull requests from @johnsonshih pull requests from @kejxu pull requests from @seanyen","title":"Open pull requests from MSFT contributors"},{"location":"ROSAtMS/AzureVM.html","text":"Azure Virtual Machine Templates Azure Virtual Machines (VM) is one of several types of on-demand, scalable computing resources that Azure offers. Microsoft provides many Azure VM templates to bootstrap ROS and ROS 2 environments. For Windows VM, see ROS on Azure with Windows VM . For Linux VM, see ROS on Azure with Linux VM . Also, you can find more template ideas on Azure Quickstart Templates .","title":"Azure VM with ROS"},{"location":"ROSAtMS/AzureVM.html#azure-virtual-machine-templates","text":"Azure Virtual Machines (VM) is one of several types of on-demand, scalable computing resources that Azure offers. Microsoft provides many Azure VM templates to bootstrap ROS and ROS 2 environments. For Windows VM, see ROS on Azure with Windows VM . For Linux VM, see ROS on Azure with Linux VM . Also, you can find more template ideas on Azure Quickstart Templates .","title":"Azure Virtual Machine Templates"},{"location":"ROSAtMS/WinML.html","text":"Windows ML ROS Node The AI platform in Windows 10 enables developers to use pre-trained machine learning models in their Apps on Windows devices. This offers developers a number of benefits: Low latency, real-time results. Windows can perform AI evaluation tasks using the local processing capabilities of the PC, enabling real-time analysis of large local data such as images and video. Results can be delivered quickly and efficiently for use in performance intensive workloads like game engines, or background tasks such as indexing for search. Reduced operational costs. Together with Microsoft\u2019s Cloud AI platform, developers can build affordable, end-to-end AI solutions that combine training models in Azure with deployment to Windows devices for evaluation. Significant savings can be realized by reducing or eliminating costs associated with bandwidth due to ingestion of large data sets, such as camera footage or sensor telemetry. Complex workloads can be processed in real-time on the edge, with minimal sample data sent to the cloud for improved training on observations. Flexibility. Developers can choose to perform AI tasks on device or in the cloud based on what their customers & scenarios need. AI processing can happen on the device if it becomes disconnected, or in scenarios where data cannot be sent to the cloud due to cost, size, policy or customer preference. Consuming WinML Requirements: Install Visual Studio 2019 with UWP development ROS melodic for Windows The WinML ROS Node is distrubted as source. To consume it in your robot, clone the winml_tracker sources into your workspace. For example: mkdir c:\\workspace\\winml_demo\\src cd c:\\workspace\\winml_demo\\src catkin_init_workspace git clone https://github.com/ms-iot/winml_tracker Create a Launch file, which references the model.onnx file: <launch> <arg name= \"onnx_model_path_arg\" default= \"$(find winml_tracker)/testdata/model.onnx\" /> <node pkg= \"winml_tracker\" type= \"winml_tracker_node\" name= \"winml_tracker\" output= \"screen\" > <param name= \"onnx_model_path\" value= \"$(arg onnx_model_path_arg)\" /> <param name= \"confidence\" value= \"0.5\" /> <param name= \"tensor_width\" value= \"416\" /> <param name= \"tensor_height\" value= \"416\" /> <param name= \"tracker_type\" value= \"yolo\" /> <param name= \"image_processing\" value= \"resize\" /> <param name= \"debug\" value= \"true\" /> <param name= \"image_topic\" value= \"/cv_camera/image_raw\" /> </node> <!-- NOTE: The image properties need to be valid for the camera, or the node will auto select the closest values --> <node pkg= \"cv_camera\" type= \"cv_camera_node\" name= \"cv_camera\" output= \"screen\" > <param name= \"rate\" type= \"double\" value= \"5.0\" /> <param name= \"image_width\" type= \"double\" value= \"640\" /> <param name= \"image_height\" type= \"double\" value= \"480\" /> </node> <node pkg= \"tf\" type= \"static_transform_publisher\" name= \"winml_link\" args= \"0 -0.02 0 0 0 0 map base_link 100\" /> </launch> While 'Pose' processing is enabled, the service required to generate the model has not been published as of October 2020 Property Descriptions Property Description onnx_model_path Path to the model.onnx file confidence Minimum confidence before publishing an event. 0 to 1 tensor_width The Width of the input to the model. tensor_height The Height of the input to the model. tracker_type Currently enabled - yolo or pose . image_processing resize , scale or crop debug true or false determines if a debug image is published image_topic The image topic to subscribe to label used to filter the found object to a specific label mesh_rotation The orientation of the mesh when debug rendering pose mesh_scale The scale of the mesh when debug rendering pose mesh_resource The mesh used for debug rendering pose model_bounds 9 coordinates used to perform the point in perspective caluclation for pose calibration Path to the OpenCV calibration file for point in persective Subscriptions WinML subscribes to the topic listed in the image_topic property, or /cv_camera/image_raw Publishing The WinML Publishes the following topics: /tracked_objects/image Outputs an image with highlighing if the debug property is set /tracked_objects/ An array of visualization_msgs::Marker for found objects /detected_object A single instance of the DetectedObjectPose message, which is output when tracker_type is set to pose.","title":"Windows ML ROS Node"},{"location":"ROSAtMS/WinML.html#windows-ml-ros-node","text":"The AI platform in Windows 10 enables developers to use pre-trained machine learning models in their Apps on Windows devices. This offers developers a number of benefits: Low latency, real-time results. Windows can perform AI evaluation tasks using the local processing capabilities of the PC, enabling real-time analysis of large local data such as images and video. Results can be delivered quickly and efficiently for use in performance intensive workloads like game engines, or background tasks such as indexing for search. Reduced operational costs. Together with Microsoft\u2019s Cloud AI platform, developers can build affordable, end-to-end AI solutions that combine training models in Azure with deployment to Windows devices for evaluation. Significant savings can be realized by reducing or eliminating costs associated with bandwidth due to ingestion of large data sets, such as camera footage or sensor telemetry. Complex workloads can be processed in real-time on the edge, with minimal sample data sent to the cloud for improved training on observations. Flexibility. Developers can choose to perform AI tasks on device or in the cloud based on what their customers & scenarios need. AI processing can happen on the device if it becomes disconnected, or in scenarios where data cannot be sent to the cloud due to cost, size, policy or customer preference.","title":"Windows ML ROS Node"},{"location":"ROSAtMS/WinML.html#consuming-winml","text":"Requirements: Install Visual Studio 2019 with UWP development ROS melodic for Windows The WinML ROS Node is distrubted as source. To consume it in your robot, clone the winml_tracker sources into your workspace. For example: mkdir c:\\workspace\\winml_demo\\src cd c:\\workspace\\winml_demo\\src catkin_init_workspace git clone https://github.com/ms-iot/winml_tracker Create a Launch file, which references the model.onnx file: <launch> <arg name= \"onnx_model_path_arg\" default= \"$(find winml_tracker)/testdata/model.onnx\" /> <node pkg= \"winml_tracker\" type= \"winml_tracker_node\" name= \"winml_tracker\" output= \"screen\" > <param name= \"onnx_model_path\" value= \"$(arg onnx_model_path_arg)\" /> <param name= \"confidence\" value= \"0.5\" /> <param name= \"tensor_width\" value= \"416\" /> <param name= \"tensor_height\" value= \"416\" /> <param name= \"tracker_type\" value= \"yolo\" /> <param name= \"image_processing\" value= \"resize\" /> <param name= \"debug\" value= \"true\" /> <param name= \"image_topic\" value= \"/cv_camera/image_raw\" /> </node> <!-- NOTE: The image properties need to be valid for the camera, or the node will auto select the closest values --> <node pkg= \"cv_camera\" type= \"cv_camera_node\" name= \"cv_camera\" output= \"screen\" > <param name= \"rate\" type= \"double\" value= \"5.0\" /> <param name= \"image_width\" type= \"double\" value= \"640\" /> <param name= \"image_height\" type= \"double\" value= \"480\" /> </node> <node pkg= \"tf\" type= \"static_transform_publisher\" name= \"winml_link\" args= \"0 -0.02 0 0 0 0 map base_link 100\" /> </launch> While 'Pose' processing is enabled, the service required to generate the model has not been published as of October 2020","title":"Consuming WinML"},{"location":"ROSAtMS/WinML.html#property-descriptions","text":"Property Description onnx_model_path Path to the model.onnx file confidence Minimum confidence before publishing an event. 0 to 1 tensor_width The Width of the input to the model. tensor_height The Height of the input to the model. tracker_type Currently enabled - yolo or pose . image_processing resize , scale or crop debug true or false determines if a debug image is published image_topic The image topic to subscribe to label used to filter the found object to a specific label mesh_rotation The orientation of the mesh when debug rendering pose mesh_scale The scale of the mesh when debug rendering pose mesh_resource The mesh used for debug rendering pose model_bounds 9 coordinates used to perform the point in perspective caluclation for pose calibration Path to the OpenCV calibration file for point in persective","title":"Property Descriptions"},{"location":"ROSAtMS/WinML.html#subscriptions","text":"WinML subscribes to the topic listed in the image_topic property, or /cv_camera/image_raw","title":"Subscriptions"},{"location":"ROSAtMS/WinML.html#publishing","text":"The WinML Publishes the following topics:","title":"Publishing"},{"location":"ROSAtMS/WinML.html#tracked_objectsimage","text":"Outputs an image with highlighing if the debug property is set","title":"/tracked_objects/image"},{"location":"ROSAtMS/WinML.html#tracked_objects","text":"An array of visualization_msgs::Marker for found objects","title":"/tracked_objects/"},{"location":"ROSAtMS/WinML.html#detected_object","text":"A single instance of the DetectedObjectPose message, which is output when tracker_type is set to pose.","title":"/detected_object"},{"location":"Turtlebot/Turtlebot3.html","text":"TurtleBot3 Getting Started with the TurtleBot3 running Windows. The ROS for Ubuntu documentation is located at the ROBOTIS website . The documentation on this page will describe the differences between Ubuntu and Windows. Windows Requirements Windows Software The TurtleBot3 uses a Lidar which requires the following driver. CP2102 Driver General notes The TurtleBot3 documentation uses the unix command 'export' to set environment variables, instead use the following: set TURTLEBOT3_MODEL = waffle NOTE: The value of %TURTLEBOT3_MODEL% is case-sensitive. Step 1: Setup PC Setup Please follow the instructions for setting up your computer with ROS on Windows . SBC Setup You can bypass this section. OpenCR Setup Please follow the Windows instructions for the ROBOTIS OpenCR board in the ROBOTIS Manual . Before proceeding, make sure the motors turn by pressing the motor test buttons near the USB connector. Compatible devices ROS on Windows requires a x64 bit Windows 10 Desktop or Windows 10 IoT Enterprise, and compatible hardware. ROS on Windows was brought up using UP2 and an Intel NUC. Step 2: Create a new Workspace In a Command Window set up with the ROS environment, create a directory for your robot workspaces and a workspace for TurtleBot3. mkdir c:\\ws\\turtlebot3\\src cd c:\\ws\\turtlebot3 curl -o tb3.repos https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_ros1.repos vcs import src < tb3.repos Step 3: Customize TurtleBot3 Launch Files Modify the ROS Launch files to map the devices to the correct COM port. To determine which COM ports you require, right click on the Windows Start Menu, Select Device Manager. Under the Ports (COM & LPT) node: USB Serial Device (COMx) is the OpenCR board. Silicon Labs CP210x USB to UART Bridge (COMy) is the Lidar. Enter the COM port in the correct fields in the launch files below: turtlebot3_bringup/launch/turtlebot3_core.launch <node pkg= \"rosserial_python\" type= \"serial_node.py\" name= \"turtlebot3_core\" output= \"screen\" > <param name= \"port\" value= \"COMx\" /> turtlebot3_bringup/launch/turtlebot3_lidar.launch <node pkg= \"hls_lfcd_lds_driver\" type= \"hlds_laser_publisher\" name= \"turtlebot3_lds\" output= \"screen\" > <param name= \"port\" value= \"COMy\" /> Step 4: Build the Workspace To build the TurtleBot3 packages, enter the TurtleBot3 workspace and build using the catkin build system. : : build TurtleBot3 workspace. cd c:\\ws\\turtlebot3 catkin_make Now inform ROS where to find your TurtleBot code by merging the TurtleBot3 install environment with the ROS environment. Please ensure you do this every time you open a command window. c : \\ws\\turtlebot3\\devel\\setup.bat If you forget to merge the TurtleBot3 environment by calling the setup batch file, you'll get an error such as this: RLException: [turtlebot3_robot.launch] is neither a launch file in package [turtlebot3_bringup] nor is [turtlebot3_bringup] a launch file name Step 5: Run TurtleBot3 No Robot - No Problem! rViz is tool which allows you to visualize a representation of a robot, and project fake data in order to exerise or develop logic. The TurtleBot3 simulation is in the turtlebot3_simulations package. To start the simulation, open one elevated command prompt: Noetic c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_fake turtlebot3_fake.launch Melodic c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_fake turtlebot3_fake.launch Then, open another elevated command prompt: Noetic c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_gazebo turtlebot3_simulation.launch Melodic c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_gazebo turtlebot3_simulation.launch Now you should see TurtleBot3 random walking on RViz. You can create your own logic which reads /odom or publish /cmd_vel to move the virtual robot. Let's try out something more! SLAM (Simultaneous localization and mapping) is a very popular application in the mobile robots, and with the simulator - Gazebo, you can exercise this technology on your Windows desktop, even without a real robot. To start this demo, open an evelated command prompt: Noetic : : run the demo. c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle curl -o turtlebot3_demo.launch https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_demo.launch roslaunch turtlebot3_demo.launch Melodic : : run the demo. c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle curl -o turtlebot3_demo.launch https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_demo.launch roslaunch turtlebot3_demo.launch After a few moments, you will see Gazebo running a simulated world with your simulated TurtleBot3, RViz running the mapping progress, and a simulation node to drive the TurtleBot3 random walking. Run TurtleBot3 with Sensors connected to your development machine. If you have TurtleBot3 hardware, you can plug the sensors directly into your development machine to iterate on fuctionality with your development machine. Perform the steps to set up the launch file for your development system. In one command window, start roscore . In another command window, launch the TurtleBot robot code. roslaunch turtlebot3_bringup turtlebot3_robot.launch","title":"TurtleBot3"},{"location":"Turtlebot/Turtlebot3.html#turtlebot3","text":"Getting Started with the TurtleBot3 running Windows. The ROS for Ubuntu documentation is located at the ROBOTIS website . The documentation on this page will describe the differences between Ubuntu and Windows.","title":"TurtleBot3"},{"location":"Turtlebot/Turtlebot3.html#windows-requirements","text":"","title":"Windows Requirements"},{"location":"Turtlebot/Turtlebot3.html#windows-software","text":"The TurtleBot3 uses a Lidar which requires the following driver. CP2102 Driver","title":"Windows Software"},{"location":"Turtlebot/Turtlebot3.html#general-notes","text":"The TurtleBot3 documentation uses the unix command 'export' to set environment variables, instead use the following: set TURTLEBOT3_MODEL = waffle NOTE: The value of %TURTLEBOT3_MODEL% is case-sensitive.","title":"General notes"},{"location":"Turtlebot/Turtlebot3.html#step-1-setup","text":"","title":"Step 1: Setup"},{"location":"Turtlebot/Turtlebot3.html#pc-setup","text":"Please follow the instructions for setting up your computer with ROS on Windows .","title":"PC Setup"},{"location":"Turtlebot/Turtlebot3.html#sbc-setup","text":"You can bypass this section.","title":"SBC Setup"},{"location":"Turtlebot/Turtlebot3.html#opencr-setup","text":"Please follow the Windows instructions for the ROBOTIS OpenCR board in the ROBOTIS Manual . Before proceeding, make sure the motors turn by pressing the motor test buttons near the USB connector.","title":"OpenCR Setup"},{"location":"Turtlebot/Turtlebot3.html#compatible-devices","text":"ROS on Windows requires a x64 bit Windows 10 Desktop or Windows 10 IoT Enterprise, and compatible hardware. ROS on Windows was brought up using UP2 and an Intel NUC.","title":"Compatible devices"},{"location":"Turtlebot/Turtlebot3.html#step-2-create-a-new-workspace","text":"In a Command Window set up with the ROS environment, create a directory for your robot workspaces and a workspace for TurtleBot3. mkdir c:\\ws\\turtlebot3\\src cd c:\\ws\\turtlebot3 curl -o tb3.repos https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_ros1.repos vcs import src < tb3.repos","title":"Step 2: Create a new Workspace"},{"location":"Turtlebot/Turtlebot3.html#step-3-customize-turtlebot3-launch-files","text":"Modify the ROS Launch files to map the devices to the correct COM port. To determine which COM ports you require, right click on the Windows Start Menu, Select Device Manager. Under the Ports (COM & LPT) node: USB Serial Device (COMx) is the OpenCR board. Silicon Labs CP210x USB to UART Bridge (COMy) is the Lidar. Enter the COM port in the correct fields in the launch files below: turtlebot3_bringup/launch/turtlebot3_core.launch <node pkg= \"rosserial_python\" type= \"serial_node.py\" name= \"turtlebot3_core\" output= \"screen\" > <param name= \"port\" value= \"COMx\" /> turtlebot3_bringup/launch/turtlebot3_lidar.launch <node pkg= \"hls_lfcd_lds_driver\" type= \"hlds_laser_publisher\" name= \"turtlebot3_lds\" output= \"screen\" > <param name= \"port\" value= \"COMy\" />","title":"Step 3: Customize TurtleBot3 Launch Files"},{"location":"Turtlebot/Turtlebot3.html#step-4-build-the-workspace","text":"To build the TurtleBot3 packages, enter the TurtleBot3 workspace and build using the catkin build system. : : build TurtleBot3 workspace. cd c:\\ws\\turtlebot3 catkin_make Now inform ROS where to find your TurtleBot code by merging the TurtleBot3 install environment with the ROS environment. Please ensure you do this every time you open a command window. c : \\ws\\turtlebot3\\devel\\setup.bat If you forget to merge the TurtleBot3 environment by calling the setup batch file, you'll get an error such as this: RLException: [turtlebot3_robot.launch] is neither a launch file in package [turtlebot3_bringup] nor is [turtlebot3_bringup] a launch file name","title":"Step 4: Build the Workspace"},{"location":"Turtlebot/Turtlebot3.html#step-5-run-turtlebot3","text":"","title":"Step 5: Run TurtleBot3"},{"location":"Turtlebot/Turtlebot3.html#no-robot-no-problem","text":"rViz is tool which allows you to visualize a representation of a robot, and project fake data in order to exerise or develop logic. The TurtleBot3 simulation is in the turtlebot3_simulations package. To start the simulation, open one elevated command prompt: Noetic c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_fake turtlebot3_fake.launch Melodic c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_fake turtlebot3_fake.launch Then, open another elevated command prompt: Noetic c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_gazebo turtlebot3_simulation.launch Melodic c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle roslaunch turtlebot3_gazebo turtlebot3_simulation.launch Now you should see TurtleBot3 random walking on RViz. You can create your own logic which reads /odom or publish /cmd_vel to move the virtual robot.","title":"No Robot - No Problem!"},{"location":"Turtlebot/Turtlebot3.html#lets-try-out-something-more","text":"SLAM (Simultaneous localization and mapping) is a very popular application in the mobile robots, and with the simulator - Gazebo, you can exercise this technology on your Windows desktop, even without a real robot. To start this demo, open an evelated command prompt: Noetic : : run the demo. c : \\opt\\ros\\noetic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle curl -o turtlebot3_demo.launch https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_demo.launch roslaunch turtlebot3_demo.launch Melodic : : run the demo. c : \\opt\\ros\\melodic\\x64\\setup.bat c : \\ws\\turtlebot3\\devel\\setup.bat set TURTLEBOT3_MODEL = waffle curl -o turtlebot3_demo.launch https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/Turtlebot/turtlebot3_demo.launch roslaunch turtlebot3_demo.launch After a few moments, you will see Gazebo running a simulated world with your simulated TurtleBot3, RViz running the mapping progress, and a simulation node to drive the TurtleBot3 random walking.","title":"Let's try out something more!"},{"location":"Turtlebot/Turtlebot3.html#run-turtlebot3-with-sensors-connected-to-your-development-machine","text":"If you have TurtleBot3 hardware, you can plug the sensors directly into your development machine to iterate on fuctionality with your development machine. Perform the steps to set up the launch file for your development system. In one command window, start roscore . In another command window, launch the TurtleBot robot code. roslaunch turtlebot3_bringup turtlebot3_robot.launch","title":"Run TurtleBot3 with Sensors connected to your development machine."},{"location":"ros2/nav2.html","text":"Navigation 2 is the next generation ROS Navigation stack for ROS 2. Edge robotics team at Microsoft has bootstrapped a Windows port for Navigation 2 . This short guide shows you how to build Navigation 2 from source and later you can get started with Navigation 2 exercises. Objectives Exercise the ROS 2 Windows installation. Bootstrap an environment running Navigation 2 samples. Prerequisites The instructions can be found on http://wiki.ros.org/Installation/Windows . \u2714\ufe0f 64-bit (amd64) environment of Windows 10 Desktop . \u2714\ufe0f Visual Studio 2019 with Desktop development with C++ workload included. \u2714\ufe0f Chocolatey package manager installed. \u2714\ufe0f Git source control software installed. Installing ROS 2 on Windows From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Open the command prompt as administrator. Run the following to install ROS 2 Foxy . mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-foxy-desktop -y --execution-timeout=0 You can close the command prompt now. \u2714\ufe0f Now you have ROS 2 ros-foxy-desktop installed. Open a Developer Command Prompt From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Run the shortcut as administrator. Once the developer command prompt is open, run : : activate the ROS 2 environment c : \\opt\\ros\\foxy\\x64\\setup.bat : : activate the Gazebo simulation environment c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" Now you are in the ROS 2 Developer command prompt. Stay in this command prompt for the rest of this tutorial. Create a Navigation 2 Workspace Create a empty workspace to contain the Navigation 2 project, and then resolve the additional dependencies. : : create a empty workspace mkdir c:\\nav2_ws\\src pushd c:\\nav2_ws : : checkout the required source code. curl -o nav2.repos https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos vcs import src < nav2.repos Build and Activate the Navigation 2 Workspace Build the workspace by colcon build tool. : : change to the root of workspace pushd c:\\nav2_ws : : build the workspace colcon build Activate the workspace which was built. : : activate it install\\setup.bat Verify your environment with Gazebo and TurtleBot3 Now you are in the Navigation 2 activated environment. Before you explore more, let's run a little exercise to make sure your environment ready to go. cd c:\\nav2_ws set GAZEBO_MODEL_PATH = C:\\nav2_ws\\install\\turtlebot3_gazebo\\share\\turtlebot3_gazebo\\models; %GAZEBO_MODEL_PATH% set TURTLEBOT3_MODEL = waffle curl -o map.pgm https://raw.githubusercontent.com/ROBOTIS-GIT/turtlebot3/master/turtlebot3_navigation/maps/map.pgm curl -o map.yaml https://raw.githubusercontent.com/ROBOTIS-GIT/turtlebot3/master/turtlebot3_navigation/maps/map.yaml start ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py start ros2 launch turtlebot3_navigation2 navigation2.launch.py map:=c:\\nav2_ws\\map.yaml After a few moment, you should see TurtleBot3 in a simulation world and the respective map shows in RViz . You can use 2D pose in RViz to give a estimate location to intialize your robot, and use 2D goal to see Navigation 2 planning a path in action. Explore Navigation 2 Samples There are many Navigation 2 resources online. Here we share some good starting points: TurtleBot3 ROS 2 Simulation: Virtual SLAM and Virtual Navigation Navigation 2","title":"Navigation 2"},{"location":"ros2/nav2.html#objectives","text":"Exercise the ROS 2 Windows installation. Bootstrap an environment running Navigation 2 samples.","title":"Objectives"},{"location":"ros2/nav2.html#prerequisites","text":"The instructions can be found on http://wiki.ros.org/Installation/Windows . \u2714\ufe0f 64-bit (amd64) environment of Windows 10 Desktop . \u2714\ufe0f Visual Studio 2019 with Desktop development with C++ workload included. \u2714\ufe0f Chocolatey package manager installed. \u2714\ufe0f Git source control software installed.","title":"Prerequisites"},{"location":"ros2/nav2.html#installing-ros-2-on-windows","text":"From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Open the command prompt as administrator. Run the following to install ROS 2 Foxy . mkdir c:\\opt\\chocolatey set ChocolateyInstall = c:\\opt\\chocolatey choco source add -n=ros-win -s= \"https://aka.ms/ros/public\" --priority=1 choco upgrade ros-foxy-desktop -y --execution-timeout=0 You can close the command prompt now. \u2714\ufe0f Now you have ROS 2 ros-foxy-desktop installed.","title":"Installing ROS 2 on Windows"},{"location":"ros2/nav2.html#open-a-developer-command-prompt","text":"From the start menu, look for x64 Native Tools Command Prompt for VS 2019 . Run the shortcut as administrator. Once the developer command prompt is open, run : : activate the ROS 2 environment c : \\opt\\ros\\foxy\\x64\\setup.bat : : activate the Gazebo simulation environment c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" Now you are in the ROS 2 Developer command prompt. Stay in this command prompt for the rest of this tutorial.","title":"Open a Developer Command Prompt"},{"location":"ros2/nav2.html#create-a-navigation-2-workspace","text":"Create a empty workspace to contain the Navigation 2 project, and then resolve the additional dependencies. : : create a empty workspace mkdir c:\\nav2_ws\\src pushd c:\\nav2_ws : : checkout the required source code. curl -o nav2.repos https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos vcs import src < nav2.repos","title":"Create a Navigation 2 Workspace"},{"location":"ros2/nav2.html#build-and-activate-the-navigation-2-workspace","text":"Build the workspace by colcon build tool. : : change to the root of workspace pushd c:\\nav2_ws : : build the workspace colcon build Activate the workspace which was built. : : activate it install\\setup.bat","title":"Build and Activate the Navigation 2 Workspace"},{"location":"ros2/nav2.html#verify-your-environment-with-gazebo-and-turtlebot3","text":"Now you are in the Navigation 2 activated environment. Before you explore more, let's run a little exercise to make sure your environment ready to go. cd c:\\nav2_ws set GAZEBO_MODEL_PATH = C:\\nav2_ws\\install\\turtlebot3_gazebo\\share\\turtlebot3_gazebo\\models; %GAZEBO_MODEL_PATH% set TURTLEBOT3_MODEL = waffle curl -o map.pgm https://raw.githubusercontent.com/ROBOTIS-GIT/turtlebot3/master/turtlebot3_navigation/maps/map.pgm curl -o map.yaml https://raw.githubusercontent.com/ROBOTIS-GIT/turtlebot3/master/turtlebot3_navigation/maps/map.yaml start ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py start ros2 launch turtlebot3_navigation2 navigation2.launch.py map:=c:\\nav2_ws\\map.yaml After a few moment, you should see TurtleBot3 in a simulation world and the respective map shows in RViz . You can use 2D pose in RViz to give a estimate location to intialize your robot, and use 2D goal to see Navigation 2 planning a path in action.","title":"Verify your environment with Gazebo and TurtleBot3"},{"location":"ros2/nav2.html#explore-navigation-2-samples","text":"There are many Navigation 2 resources online. Here we share some good starting points: TurtleBot3 ROS 2 Simulation: Virtual SLAM and Virtual Navigation Navigation 2","title":"Explore Navigation 2 Samples"},{"location":"ros2/system_tests.html","text":"This tutorial is to show how to use Azure Pielines with Scale Set Agents to exercise the Navigation2 System Tests . It is a comprehensive End-to-End test pass with Gazebo simulation. This project is a good example for ROS 2 developers how to organize a End-to-End tests across multiple packages and tools. Objectives Run and observe the Nav2 system tests running locally. Register a scale set agent with your Azure DevOps orgnization. Integrate a GitHub project with Azure Pipelines. Prerequisites An Microsoft Azure account from https://portal.azure.com . An Azure DevOps account from https://dev.azure.com . A GitHub account from https://github.com . Exercise 1: Build And Run Nav2 System Tests Locally Install ROS2 . Foxy is recommended. Open the ROS 2 command prompt and activate the Gazebo environment. c : \\opt\\ros\\foxy\\x64\\setup.bat c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set SDF_PATH = c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6 Create an empty workspace and clone the Navigation2 repositories. For example, : : create an empty workspace mkdir c:\\nav2_ws\\src cd c:\\nav2_ws : : clone the Navigation2 curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos Build the Navigation2 System Tests projects. : : then, build the nav2_system_tests colcon build --packages-select nav2_system_tests A few moment later, a similar message should be put to indicate a successful build: Summary: 1 package finished [2min 10s] In cases of any build failures, Log folder can be found under the workspace. Detailed information can be found there. Run the Nav2 System Tests colcon test --packages-select nav2_system_tests Verify the test result. colcon test-result Exercise 2: Create and Register Scale Set Agents with Azure Pipelines One of the advantages to use Scale Set Agents is that the machine usage can scale out on demend and scale in when idle. It is managed by Azure DevOps, and the cost saving can be more optimized. Navigate to Azure virtual machine scale set agents . In the instructions, you will be asked to create a Virtual Machine Scale Set . Use Visual Studio Enterprise 2019 image and NV-series virtual machines. The image URN is microsoftvisualstudio:visualstudio2019latest:vs-2019-ent-latest-ws2019:latest . The virtual machine size is Standard_NV6 . GPU-accelerated VM is required to run the simulation. In this example, we use GPU accelerated VM and the corresponding driver is required in the Virtual Machine Scale Set. Navigate to the Extension settings for your Virtual Machine Scale Set and add the following extension. Now, a new agent pool should be registered for your Azure DevOps organization and project. Keep a note of your agent pool name. Exercise 3: Integrate GitHub projects with Azure Pipelines Create a repository into your GitHub account. Create a file azure-pipelines.yml under the repository root with the following content. (Replace the pool with your agent pool name.) jobs : - job : Nav2SystemTests pool : 'VS2019-GPU' timeoutInMinutes : 360 workspace : clean : all steps : - script : | rd /s /q c:\\opt 2>&1 exit 0 displayName : 'Remove opt folder' - powershell : | $env:ChocolateyInstall=\"c:\\opt\\chocolatey\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) choco sources add -n=roswin -s https://aka.ms/ros/public --priority 1 choco install ros-foxy-desktop -y --pre --no-progress -i displayName : 'Install ROS 2 Foxy' - script : | mkdir C:\\Users\\AzDevOps\\.gazebo\\models call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\" call \"c:\\opt\\ros\\foxy\\x64\\setup.bat\" call \"c:\\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat\" set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" mkdir nav_ws\\src cd nav_ws curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import --force src < navigation2_foxy.repos colcon build --packages-select nav2_system_tests colcon test --packages-select nav2_system_tests --event-handlers console_direct+ colcon test-result displayName : 'Build and run tests' continueOnError : true timeoutInMinutes : 30 - task : PublishTestResults@2 inputs : testRunner : 'jUnit' testResultsFiles : '**\\*.xml' searchFolder : $(System.DefaultWorkingDirectory)/nav_ws/build/nav2_system_tests/test_results condition : always() - task : PublishBuildArtifacts@1 inputs : pathtoPublish : .\\nav_ws\\log artifactName : 'logs' condition : always() The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines.yml . Now you should have a pipeline running (or ready to run). In the meanwhile, you can observe the pipeline running. Once the build finishes, you can inspect the test results.","title":"Continuous Simulation for Navigation2 System Tests"},{"location":"ros2/system_tests.html#objectives","text":"Run and observe the Nav2 system tests running locally. Register a scale set agent with your Azure DevOps orgnization. Integrate a GitHub project with Azure Pipelines.","title":"Objectives"},{"location":"ros2/system_tests.html#prerequisites","text":"An Microsoft Azure account from https://portal.azure.com . An Azure DevOps account from https://dev.azure.com . A GitHub account from https://github.com .","title":"Prerequisites"},{"location":"ros2/system_tests.html#exercise-1-build-and-run-nav2-system-tests-locally","text":"Install ROS2 . Foxy is recommended. Open the ROS 2 command prompt and activate the Gazebo environment. c : \\opt\\ros\\foxy\\x64\\setup.bat c : \\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat set SDF_PATH = c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6 Create an empty workspace and clone the Navigation2 repositories. For example, : : create an empty workspace mkdir c:\\nav2_ws\\src cd c:\\nav2_ws : : clone the Navigation2 curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import src < navigation2_foxy.repos Build the Navigation2 System Tests projects. : : then, build the nav2_system_tests colcon build --packages-select nav2_system_tests A few moment later, a similar message should be put to indicate a successful build: Summary: 1 package finished [2min 10s] In cases of any build failures, Log folder can be found under the workspace. Detailed information can be found there. Run the Nav2 System Tests colcon test --packages-select nav2_system_tests Verify the test result. colcon test-result","title":"Exercise 1: Build And Run Nav2 System Tests Locally"},{"location":"ros2/system_tests.html#exercise-2-create-and-register-scale-set-agents-with-azure-pipelines","text":"One of the advantages to use Scale Set Agents is that the machine usage can scale out on demend and scale in when idle. It is managed by Azure DevOps, and the cost saving can be more optimized. Navigate to Azure virtual machine scale set agents . In the instructions, you will be asked to create a Virtual Machine Scale Set . Use Visual Studio Enterprise 2019 image and NV-series virtual machines. The image URN is microsoftvisualstudio:visualstudio2019latest:vs-2019-ent-latest-ws2019:latest . The virtual machine size is Standard_NV6 . GPU-accelerated VM is required to run the simulation. In this example, we use GPU accelerated VM and the corresponding driver is required in the Virtual Machine Scale Set. Navigate to the Extension settings for your Virtual Machine Scale Set and add the following extension. Now, a new agent pool should be registered for your Azure DevOps organization and project. Keep a note of your agent pool name.","title":"Exercise 2: Create and Register Scale Set Agents with Azure Pipelines"},{"location":"ros2/system_tests.html#exercise-3-integrate-github-projects-with-azure-pipelines","text":"Create a repository into your GitHub account. Create a file azure-pipelines.yml under the repository root with the following content. (Replace the pool with your agent pool name.) jobs : - job : Nav2SystemTests pool : 'VS2019-GPU' timeoutInMinutes : 360 workspace : clean : all steps : - script : | rd /s /q c:\\opt 2>&1 exit 0 displayName : 'Remove opt folder' - powershell : | $env:ChocolateyInstall=\"c:\\opt\\chocolatey\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) choco sources add -n=roswin -s https://aka.ms/ros/public --priority 1 choco install ros-foxy-desktop -y --pre --no-progress -i displayName : 'Install ROS 2 Foxy' - script : | mkdir C:\\Users\\AzDevOps\\.gazebo\\models call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvars64.bat\" call \"c:\\opt\\ros\\foxy\\x64\\setup.bat\" call \"c:\\opt\\ros\\foxy\\x64\\share\\gazebo\\setup.bat\" set \"SDF_PATH=c:\\opt\\ros\\foxy\\x64\\share\\sdformat\\1.6\" mkdir nav_ws\\src cd nav_ws curl https://raw.githubusercontent.com/ms-iot/ROSOnWindows/master/docs/ros2/navigation2_foxy.repos -o navigation2_foxy.repos vcs import --force src < navigation2_foxy.repos colcon build --packages-select nav2_system_tests colcon test --packages-select nav2_system_tests --event-handlers console_direct+ colcon test-result displayName : 'Build and run tests' continueOnError : true timeoutInMinutes : 30 - task : PublishTestResults@2 inputs : testRunner : 'jUnit' testResultsFiles : '**\\*.xml' searchFolder : $(System.DefaultWorkingDirectory)/nav_ws/build/nav2_system_tests/test_results condition : always() - task : PublishBuildArtifacts@1 inputs : pathtoPublish : .\\nav_ws\\log artifactName : 'logs' condition : always() The Integrate Your GitHub Projects With Azure Pipelines guides you how to create a pipeline for a GitHub project in Task 1 & 2. Use your fork as the target repository. Navigate to the \"Existing Azure Pipelines YAML file\" and select azure-pipelines.yml . Now you should have a pipeline running (or ready to run). In the meanwhile, you can observe the pipeline running. Once the build finishes, you can inspect the test results.","title":"Exercise 3: Integrate GitHub projects with Azure Pipelines"},{"location":"tutorials/ethercat/soem.html","text":"Getting Started with SOEM Application EtherCAT (Ethernet for Control Automation Technology) is an Ethernet-based fieldbus system. It is a widely used protocol for industrial applications. In this tutorial, I will show you how to install and consume an open source EtherCAT master implementation, SOEM (Simple Open EtherCAT Master), and discover devices on a EtherCAT network in a ROS workspace. For more information, visit https://github.com/OpenEtherCATsociety/SOEM . Prerequisite You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have a EtherCAT slave controller commissioned to work. You have a EtherCAT network topology configured physically. You have basic knowledge to EtherCAT technology. Step 1: Add SOEM Library to your Workspace Firstly, you will need a catkin workspace to begin with. Let's assume you are working on an empty workspace under c:\\ethercat_ws . You can install SOEM from vcpkg : : : install vcpkg SOEM port c : \\ethercat_ws > vcpkg install SOEM:x64-windows Step 2: Create your own Package Now you have the required libraries. Let's begin with a new package and build with SOEM . : : change the directory to the source subfolder. c : \\ethercat_ws > cd src : : create your owned package c : \\ethercat_ws\\src > catkin_create_pkg my_pkg Step 3: Add SOEM Application Code Copy slaveinfo.c into the new package as the SOEM application code to run. : : make the directory to store the source. c : \\ethercat_ws > mkdir src\\my_pkg\\src : : download the source of `slaveinfo.c` c : \\ethercat_ws > curl https://raw.githubusercontent.com/OpenEtherCATsociety/SOEM/master/test/linux/slaveinfo/slaveinfo.c -o src\\my_pkg\\src\\slaveinfo.c Step 4: Edit CMakeLists.txt You will also needs to edit the src\\my_pkg\\CMakeLists.txt to author the new executable and to be explicit on SOEM as dependency. Here is the CMake recipe to add to look for SOEM : find_path ( winpcap_INCLUDE_DIRS NAMES pcap.h ) find_library ( winpcap_LIBRARY NAMES wpcap ) find_library ( packet_LIBRARY NAMES packet ) find_path ( soem_INCLUDE_DIRS NAMES ethercat.h PATH_SUFFIXES soem ) find_library ( soem_LIBRARY NAMES soem ) Here is the recipe to author the slaveinfo.c as an excutable: include_directories ( ${ catkin_INCLUDE_DIRS } ${ soem_INCLUDE_DIRS } ${ winpcap_INCLUDE_DIRS } ) add_executable ( ${ PROJECT_NAME } _node src/slaveinfo.c ) set_target_properties ( ${ PROJECT_NAME } _node PROPERTIES OUTPUT_NAME slaveinfo PREFIX \"\" ) add_dependencies ( ${ PROJECT_NAME } _node ${ ${PROJECT_NAME } _EXPORTED_TARGETS} ${ catkin_EXPORTED_TARGETS } ) target_link_libraries ( ${ PROJECT_NAME } _node ${ catkin_LIBRARIES } ${ soem_LIBRARY } ${ winpcap_LIBRARY } ${ packet_LIBRARY } Ws2_32.lib Winmm.lib ) Step 5: Build the Workspace Let's build the workspace to produce the executables and binaries. And remember to run setup.bat to add the development space into the current environment. : : Build the workspace c : \\ethercat_ws > catkin_make : : Add the development space into the current environment. c : \\ethercat_ws > devel\\setup.bat Step 6: Check EtherCAT Network Let's check the EtherCAT network to make sure the SOEM and the EtherCAT network is working. First, retrieve the list of ethernet adapter discovered on your machine. c : \\ethercat_ws > rosrun my_pkg slaveinfo SOEM (Simple Open EtherCAT Master) Slaveinfo Usage: slaveinfo ifname [options] ifname = eth0 for example Options : -sdo : print SDO info -map : print mapping Available adapters Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{7B78D297-ED15-4C1B-BC32-8EDB9E41E5AB} Description : VMware Virtual Ethernet Adapter, Device to use for wpcap: \\Device\\NPF_{8BBA06A7-8AAB-48B5-90E3-DC2DB31D86F6} Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{BF10C5FD-EF74-4D93-B32E-D0D2A040BA87} Description : Microsoft Corporation, Device to use for wpcap: \\Device\\NPF_{894B5E76-A359-4AAF-8F7C-41FAD68773E3} Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} Description : VMware Virtual Ethernet Adapter, Device to use for wpcap: \\Device\\NPF_{144028BF-951B-4209-B8D4-30E888BFB4CB} End program Look for the ethernet adapter for your EtherCAT network and take a note of the path, for example, \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} . Now run the slaveinfo with the ethernet device path again to list what EtherCAT slave controllers are discovered on the network. You should see information similar to the below and check that the details make sense to your environment. c : \\ethercat_ws > rosrun soem slaveinfo \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} Slave:1 Name:simco drive 40028083-00-0 Output size: 48bits Input size: 48bits State: 4 Delay: 0[ns] Has DC: 0 Activeports:1.1.0.0 Configured address: 1002 Man: 0000010a ID: 0262c7b3 Rev: 00010211 SM0 A:1000 L: 512 F:00010026 Type:1 SM1 A:1400 L: 512 F:00010022 Type:2 SM2 A:1800 L: 6 F:00010064 Type:3 SM3 A:1950 L: 6 F:00010020 Type:4 FMMU0 Ls:0000000a Ll: 6 Lsb:0 Leb:7 Ps:1800 Psb:0 Ty:02 Act:01 FMMU1 Ls:00000027 Ll: 6 Lsb:0 Leb:7 Ps:1950 Psb:0 Ty:01 Act:01 FMMUfunc 0:1 1:2 2:0 3:0 MBX length wr: 512 rd: 512 MBX protocols : 0c CoE details: 27 FoE details: 01 EoE details: 00 SoE details: 00 Ebus current: 0[mA] only LRD/LWR:0 PDO mapping according to CoE : SM2 outputs addr b index: sub bitl data_type name [0x000A.0] 0x6040:0x00 0x10 UNSIGNED16 Controlword [0x000C.0] 0x60FF:0x00 0x20 INTEGER32 Target Velocity [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 SM3 inputs addr b index: sub bitl data_type name [0x0027.0] 0x6041:0x00 0x10 UNSIGNED16 Statusword [0x0029.0] 0x6064:0x00 0x20 INTEGER32 Position Actual Value [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 Summary Now you have a workspace to continue the learning of SOEM . In this tutorial, I walk through the steps of installing SOEM from vcpkg , how to edit catkin package to consume SOEM , and how to run slaveinfo to exercise your EtherCAT network. I encourge you to read on the official SOEM tutorial to learn more about how to program SOEM application.","title":"Simple Open EtherCAT Master"},{"location":"tutorials/ethercat/soem.html#getting-started-with-soem-application","text":"EtherCAT (Ethernet for Control Automation Technology) is an Ethernet-based fieldbus system. It is a widely used protocol for industrial applications. In this tutorial, I will show you how to install and consume an open source EtherCAT master implementation, SOEM (Simple Open EtherCAT Master), and discover devices on a EtherCAT network in a ROS workspace. For more information, visit https://github.com/OpenEtherCATsociety/SOEM .","title":"Getting Started with SOEM Application"},{"location":"tutorials/ethercat/soem.html#prerequisite","text":"You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have a EtherCAT slave controller commissioned to work. You have a EtherCAT network topology configured physically. You have basic knowledge to EtherCAT technology.","title":"Prerequisite"},{"location":"tutorials/ethercat/soem.html#step-1-add-soem-library-to-your-workspace","text":"Firstly, you will need a catkin workspace to begin with. Let's assume you are working on an empty workspace under c:\\ethercat_ws . You can install SOEM from vcpkg : : : install vcpkg SOEM port c : \\ethercat_ws > vcpkg install SOEM:x64-windows","title":"Step 1: Add SOEM Library to your Workspace"},{"location":"tutorials/ethercat/soem.html#step-2-create-your-own-package","text":"Now you have the required libraries. Let's begin with a new package and build with SOEM . : : change the directory to the source subfolder. c : \\ethercat_ws > cd src : : create your owned package c : \\ethercat_ws\\src > catkin_create_pkg my_pkg","title":"Step 2: Create your own Package"},{"location":"tutorials/ethercat/soem.html#step-3-add-soem-application-code","text":"Copy slaveinfo.c into the new package as the SOEM application code to run. : : make the directory to store the source. c : \\ethercat_ws > mkdir src\\my_pkg\\src : : download the source of `slaveinfo.c` c : \\ethercat_ws > curl https://raw.githubusercontent.com/OpenEtherCATsociety/SOEM/master/test/linux/slaveinfo/slaveinfo.c -o src\\my_pkg\\src\\slaveinfo.c","title":"Step 3: Add SOEM Application Code"},{"location":"tutorials/ethercat/soem.html#step-4-edit-cmakeliststxt","text":"You will also needs to edit the src\\my_pkg\\CMakeLists.txt to author the new executable and to be explicit on SOEM as dependency. Here is the CMake recipe to add to look for SOEM : find_path ( winpcap_INCLUDE_DIRS NAMES pcap.h ) find_library ( winpcap_LIBRARY NAMES wpcap ) find_library ( packet_LIBRARY NAMES packet ) find_path ( soem_INCLUDE_DIRS NAMES ethercat.h PATH_SUFFIXES soem ) find_library ( soem_LIBRARY NAMES soem ) Here is the recipe to author the slaveinfo.c as an excutable: include_directories ( ${ catkin_INCLUDE_DIRS } ${ soem_INCLUDE_DIRS } ${ winpcap_INCLUDE_DIRS } ) add_executable ( ${ PROJECT_NAME } _node src/slaveinfo.c ) set_target_properties ( ${ PROJECT_NAME } _node PROPERTIES OUTPUT_NAME slaveinfo PREFIX \"\" ) add_dependencies ( ${ PROJECT_NAME } _node ${ ${PROJECT_NAME } _EXPORTED_TARGETS} ${ catkin_EXPORTED_TARGETS } ) target_link_libraries ( ${ PROJECT_NAME } _node ${ catkin_LIBRARIES } ${ soem_LIBRARY } ${ winpcap_LIBRARY } ${ packet_LIBRARY } Ws2_32.lib Winmm.lib )","title":"Step 4: Edit CMakeLists.txt"},{"location":"tutorials/ethercat/soem.html#step-5-build-the-workspace","text":"Let's build the workspace to produce the executables and binaries. And remember to run setup.bat to add the development space into the current environment. : : Build the workspace c : \\ethercat_ws > catkin_make : : Add the development space into the current environment. c : \\ethercat_ws > devel\\setup.bat","title":"Step 5: Build the Workspace"},{"location":"tutorials/ethercat/soem.html#step-6-check-ethercat-network","text":"Let's check the EtherCAT network to make sure the SOEM and the EtherCAT network is working. First, retrieve the list of ethernet adapter discovered on your machine. c : \\ethercat_ws > rosrun my_pkg slaveinfo SOEM (Simple Open EtherCAT Master) Slaveinfo Usage: slaveinfo ifname [options] ifname = eth0 for example Options : -sdo : print SDO info -map : print mapping Available adapters Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{7B78D297-ED15-4C1B-BC32-8EDB9E41E5AB} Description : VMware Virtual Ethernet Adapter, Device to use for wpcap: \\Device\\NPF_{8BBA06A7-8AAB-48B5-90E3-DC2DB31D86F6} Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{BF10C5FD-EF74-4D93-B32E-D0D2A040BA87} Description : Microsoft Corporation, Device to use for wpcap: \\Device\\NPF_{894B5E76-A359-4AAF-8F7C-41FAD68773E3} Description : Microsoft, Device to use for wpcap: \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} Description : VMware Virtual Ethernet Adapter, Device to use for wpcap: \\Device\\NPF_{144028BF-951B-4209-B8D4-30E888BFB4CB} End program Look for the ethernet adapter for your EtherCAT network and take a note of the path, for example, \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} . Now run the slaveinfo with the ethernet device path again to list what EtherCAT slave controllers are discovered on the network. You should see information similar to the below and check that the details make sense to your environment. c : \\ethercat_ws > rosrun soem slaveinfo \\Device\\NPF_{A54146EA-CD6F-4A95-93E4-0919C4B2D685} Slave:1 Name:simco drive 40028083-00-0 Output size: 48bits Input size: 48bits State: 4 Delay: 0[ns] Has DC: 0 Activeports:1.1.0.0 Configured address: 1002 Man: 0000010a ID: 0262c7b3 Rev: 00010211 SM0 A:1000 L: 512 F:00010026 Type:1 SM1 A:1400 L: 512 F:00010022 Type:2 SM2 A:1800 L: 6 F:00010064 Type:3 SM3 A:1950 L: 6 F:00010020 Type:4 FMMU0 Ls:0000000a Ll: 6 Lsb:0 Leb:7 Ps:1800 Psb:0 Ty:02 Act:01 FMMU1 Ls:00000027 Ll: 6 Lsb:0 Leb:7 Ps:1950 Psb:0 Ty:01 Act:01 FMMUfunc 0:1 1:2 2:0 3:0 MBX length wr: 512 rd: 512 MBX protocols : 0c CoE details: 27 FoE details: 01 EoE details: 00 SoE details: 00 Ebus current: 0[mA] only LRD/LWR:0 PDO mapping according to CoE : SM2 outputs addr b index: sub bitl data_type name [0x000A.0] 0x6040:0x00 0x10 UNSIGNED16 Controlword [0x000C.0] 0x60FF:0x00 0x20 INTEGER32 Target Velocity [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 [0x0010.0] 0x0000:0x00 0x00 SM3 inputs addr b index: sub bitl data_type name [0x0027.0] 0x6041:0x00 0x10 UNSIGNED16 Statusword [0x0029.0] 0x6064:0x00 0x20 INTEGER32 Position Actual Value [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00 [0x002D.0] 0x0000:0x00 0x00","title":"Step 6: Check EtherCAT Network"},{"location":"tutorials/ethercat/soem.html#summary","text":"Now you have a workspace to continue the learning of SOEM . In this tutorial, I walk through the steps of installing SOEM from vcpkg , how to edit catkin package to consume SOEM , and how to run slaveinfo to exercise your EtherCAT network. I encourge you to read on the official SOEM tutorial to learn more about how to program SOEM application.","title":"Summary"},{"location":"tutorials/peak/peak.html","text":"Controller Area Network (CAN) is one of the widely used Fieldbus protocols in industrial automation. On Linux, applications can talk to a CAN bus over SocketCAN. On Windows, applications talk to a CAN bus using vendor-provided libraries. Today we are demonstrate how to use a CAN library, PCAN-Basic , from PEAK-System Technik GmbH . In this tutorial, we will show you an example how to begin with a ROS package, integrate with the CAN library, and perform the basic I/O to a CAN Bus. For more details, visit PEAK-System . Prerequisite You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have PCAN adapters. We use PCAN-miniPCIe in this tutorial. You have the CAN adapters connected to a CAN network and all devices are commissioned to work. You have a ROS command prompt ready to use. Step 1: Creating a ROS package Firstly, you will need a catkin workspace to begin with. Assuming you have an empty workspace under c:\\can_ws , now create a new package. : : change the directory to the source subfolder. c : \\can_ws > cd src : : create your owned package c : \\can_ws\\src > catkin_create_pkg my_pkg Step 2: Adding PCAN-Basic SDK The next step is to add PCAN-Basic library into your package. This example shows a way to pull and place the library into the correct location by CMake convention. Now open and edit the CMakeLists.txt under src\\my_pkg . # Decide what architecture for the target set ( TARGET_ARCH \"Win32\" ) if ( CMAKE_SIZEOF_VOID_P EQUAL 8 ) set ( TARGET_ARCH \"x64\" ) endif () # Create locations to place the PCAN-Basic library file ( MAKE_DIRECTORY ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include ) # Pull down the PCAN-Basic library include ( ExternalProject ) ExternalProject_Add ( pcan-basic URL https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip URL_MD5 d388e723046e7b2f6bd06489a12a3d96 PREFIX ${ CMAKE_BINARY_DIR } /pcan-basic CONFIGURE_COMMAND \"\" BUILD_COMMAND \"\" INSTALL_COMMAND ${ CMAKE_COMMAND } -E copy_directory <SOURCE_DIR>/include ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include COMMAND ${ CMAKE_COMMAND } -E copy <SOURCE_DIR>/ ${ TARGET_ARCH } /PCANBasic.dll ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin COMMAND ${ CMAKE_COMMAND } -E copy <SOURCE_DIR>/ ${ TARGET_ARCH } /VC_LIB/PCANBasic.lib ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib LOG_DOWNLOAD ON LOG_INSTALL ON ) # Initialize include paths and library paths set ( pcan_LIBRARIES ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib/PCANBasic.lib ) set ( pcan_INCLUDE_DIRS ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include ) # Remember to install the DLL side-by-side to ROS application install ( FILES ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin/PCANBasic.dll DESTINATION ${ CATKIN_GLOBAL_BIN_DESTINATION } ) And now you can build the package and see if everything is set up correctly. : : Build the workspace c : \\can_ws > catkin_make install : : Add the install space into the current environment. c : \\can_ws > install\\setup.bat Step 3: Adding Simple CAN Read\\Write Loop Now you have the PCAN-Basic library ready to use in your ROS workspace. We are going to add a simple node doing the basic read/write loop. Now you go to the editor, create a file of src/my_pkg/src/my_pkg_node.cpp under your workspace, and copy & paste the below code: #include <windows.h> #include <PCANBasic.h> #include <exception> #include <iostream> #include <ros/ros.h> #include <ros/callback_queue.h> #include <ros/console.h> class PCANLoop { public : PCANLoop () { TPCANStatus result = CAN_Initialize ( PCAN_PCIBUS1 , PCAN_BAUD_500K ); if ( result != PCAN_ERROR_OK ) { throw std :: runtime_error ( \"CAN_Initialize failed.\" ); } } void process () { send (); while ( read ()); // process till the queue goes empty } private : bool read () { TPCANMsg received = { 0 }; TPCANStatus result = CAN_Read ( PCAN_PCIBUS1 , & received , NULL ); if ( result == PCAN_ERROR_QRCVEMPTY ) { return false ; } else if ( result == PCAN_ERROR_OK ) { // COMMENT: read the message here. return true ; } throw std :: runtime_error ( \"CAN_Read failed.\" ); } void send () { // COMMENT: replace the message with yours. TPCANMsg request = { 0 }; request . ID = 0 ; request . MSGTYPE = PCAN_MESSAGE_STANDARD ; request . LEN = 8 ; TPCANStatus result = CAN_Write ( PCAN_PCIBUS1 , & request ); if ( result != PCAN_ERROR_OK ) { throw std :: runtime_error ( \"CAN_Write failed.\" ); } } }; /** * Control loop for PCAN */ void controlLoop ( PCANLoop & loop ) { try { loop . process (); } catch ( std :: exception & e ) { ROS_ERROR_STREAM ( \"controlLoop exception:\" << e . what ()); } } int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"my_node\" ); ros :: NodeHandle nh , private_nh ( \"~\" ); try { double control_frequency ; private_nh . param < double > ( \"control_frequency\" , control_frequency , 50.0 ); PCANLoop loop ; ros :: CallbackQueue queue ; ros :: AsyncSpinner spinner ( 1 , & queue ); ros :: TimerOptions control_timer ( ros :: Duration ( 1 / control_frequency ), boost :: bind ( controlLoop , boost :: ref ( loop )), & queue ); ros :: Timer control_loop = nh . createTimer ( control_timer ); spinner . start (); // Process remainder of ROS callbacks separately, mainly ControlManager related ros :: spin (); } catch ( std :: exception & e ) { ROS_ERROR_STREAM ( \"exception:\" << e . what ()); } return 0 ; } We will explain the code later. We need to describe the new node and its dependency in CMakeLists.txt and package.xml . Now open and edit the src\\my_pkg\\CMakeLists.txt file under the workspace. src\\my_pkg\\CMakeLists.txt Below is an example to describe a new node in CMake . ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages find_package ( catkin REQUIRED COMPONENTS roscpp ) ... ########### ## Build ## ########### ## Specify additional locations of header files ## Your package locations should be listed before other locations include_directories ( ${ catkin_INCLUDE_DIRS } ${ pcan_INCLUDE_DIRS } ) ## Declare a C++ executable ## With catkin_make all packages are built within a single CMake context ## The recommended prefix ensures that target names across packages don't collide add_executable ( ${ PROJECT_NAME } _node src/my_pkg_node.cpp ) ## Rename C++ executable without prefix ## The above recommended prefix causes long target names, the following renames the ## target back to the shorter version for ease of user use ## e.g. \"rosrun someones_pkg node\" instead of \"rosrun someones_pkg someones_pkg_node\" set_target_properties ( ${ PROJECT_NAME } _node PROPERTIES OUTPUT_NAME node PREFIX \"\" ) ## Add cmake target dependencies of the executable ## same as for the library above add_dependencies ( ${ PROJECT_NAME } _node ${ ${PROJECT_NAME } _EXPORTED_TARGETS} ${ catkin_EXPORTED_TARGETS } ) ## Specify libraries to link a library or executable target against target_link_libraries ( ${ PROJECT_NAME } _node ${ catkin_LIBRARIES } ${ pcan_LIBRARIES } ) ############# ## Install ## ############# # all install targets should use catkin DESTINATION variables # See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html ## Mark executables for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html install ( TARGETS ${ PROJECT_NAME } _node RUNTIME DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) src\\my_pkg\\package.xml Make sure roscpp in the <depend> list. <?xml version=\"1.0\"?> <package format= \"2\" > <name> my_pkg </name> ... <depend> roscpp </depend> ... </package> Simple CAN Read/Write Loop In this example, we use Callback and Spinning from roscpp to set up a control loop running at 50Hz. In the callback, we read all the messages from the PCAN message queue and send a empty message to the CAN Bus. Depending on your CAN devices, you may need to add more protocol-specific implementation on top of the basic I/O. Step 4: Building the Workspace Now we have all the code in place. Let's rebuild the workspace again to ensure everything built. : : Build the workspace c : \\can_ws > catkin_make install : : Add the install space into the current environment. c : \\can_ws > install\\setup.bat Step 5: Running the ROS Application Before we launch the application, we need to make sure rosmaster is up and running. Start another ROS command prompt and run roscore . Now we are ready to run this application. c : \\can_ws > rosrun my_pkg node Summary In this tutorial, we walk through the steps of integrate PCAN-Basic library into your ROS package, how to consume it by an simple CAN read/write loop application. You are encouraged to proceed on the official PCAN-Basic documentation to learn more.","title":"PEAK-System&reg; PCAN&reg;-Basic"},{"location":"tutorials/peak/peak.html#prerequisite","text":"You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have PCAN adapters. We use PCAN-miniPCIe in this tutorial. You have the CAN adapters connected to a CAN network and all devices are commissioned to work. You have a ROS command prompt ready to use.","title":"Prerequisite"},{"location":"tutorials/peak/peak.html#step-1-creating-a-ros-package","text":"Firstly, you will need a catkin workspace to begin with. Assuming you have an empty workspace under c:\\can_ws , now create a new package. : : change the directory to the source subfolder. c : \\can_ws > cd src : : create your owned package c : \\can_ws\\src > catkin_create_pkg my_pkg","title":"Step 1: Creating a ROS package"},{"location":"tutorials/peak/peak.html#step-2-adding-pcan-basic-sdk","text":"The next step is to add PCAN-Basic library into your package. This example shows a way to pull and place the library into the correct location by CMake convention. Now open and edit the CMakeLists.txt under src\\my_pkg . # Decide what architecture for the target set ( TARGET_ARCH \"Win32\" ) if ( CMAKE_SIZEOF_VOID_P EQUAL 8 ) set ( TARGET_ARCH \"x64\" ) endif () # Create locations to place the PCAN-Basic library file ( MAKE_DIRECTORY ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include ) # Pull down the PCAN-Basic library include ( ExternalProject ) ExternalProject_Add ( pcan-basic URL https://www.peak-system.com/fileadmin/media/files/pcan-basic.zip URL_MD5 d388e723046e7b2f6bd06489a12a3d96 PREFIX ${ CMAKE_BINARY_DIR } /pcan-basic CONFIGURE_COMMAND \"\" BUILD_COMMAND \"\" INSTALL_COMMAND ${ CMAKE_COMMAND } -E copy_directory <SOURCE_DIR>/include ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include COMMAND ${ CMAKE_COMMAND } -E copy <SOURCE_DIR>/ ${ TARGET_ARCH } /PCANBasic.dll ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin COMMAND ${ CMAKE_COMMAND } -E copy <SOURCE_DIR>/ ${ TARGET_ARCH } /VC_LIB/PCANBasic.lib ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib LOG_DOWNLOAD ON LOG_INSTALL ON ) # Initialize include paths and library paths set ( pcan_LIBRARIES ${ CMAKE_BINARY_DIR } /installed/pcan-basic/lib/PCANBasic.lib ) set ( pcan_INCLUDE_DIRS ${ CMAKE_BINARY_DIR } /installed/pcan-basic/include ) # Remember to install the DLL side-by-side to ROS application install ( FILES ${ CMAKE_BINARY_DIR } /installed/pcan-basic/bin/PCANBasic.dll DESTINATION ${ CATKIN_GLOBAL_BIN_DESTINATION } ) And now you can build the package and see if everything is set up correctly. : : Build the workspace c : \\can_ws > catkin_make install : : Add the install space into the current environment. c : \\can_ws > install\\setup.bat","title":"Step 2: Adding PCAN-Basic SDK"},{"location":"tutorials/peak/peak.html#step-3-adding-simple-can-readwrite-loop","text":"Now you have the PCAN-Basic library ready to use in your ROS workspace. We are going to add a simple node doing the basic read/write loop. Now you go to the editor, create a file of src/my_pkg/src/my_pkg_node.cpp under your workspace, and copy & paste the below code: #include <windows.h> #include <PCANBasic.h> #include <exception> #include <iostream> #include <ros/ros.h> #include <ros/callback_queue.h> #include <ros/console.h> class PCANLoop { public : PCANLoop () { TPCANStatus result = CAN_Initialize ( PCAN_PCIBUS1 , PCAN_BAUD_500K ); if ( result != PCAN_ERROR_OK ) { throw std :: runtime_error ( \"CAN_Initialize failed.\" ); } } void process () { send (); while ( read ()); // process till the queue goes empty } private : bool read () { TPCANMsg received = { 0 }; TPCANStatus result = CAN_Read ( PCAN_PCIBUS1 , & received , NULL ); if ( result == PCAN_ERROR_QRCVEMPTY ) { return false ; } else if ( result == PCAN_ERROR_OK ) { // COMMENT: read the message here. return true ; } throw std :: runtime_error ( \"CAN_Read failed.\" ); } void send () { // COMMENT: replace the message with yours. TPCANMsg request = { 0 }; request . ID = 0 ; request . MSGTYPE = PCAN_MESSAGE_STANDARD ; request . LEN = 8 ; TPCANStatus result = CAN_Write ( PCAN_PCIBUS1 , & request ); if ( result != PCAN_ERROR_OK ) { throw std :: runtime_error ( \"CAN_Write failed.\" ); } } }; /** * Control loop for PCAN */ void controlLoop ( PCANLoop & loop ) { try { loop . process (); } catch ( std :: exception & e ) { ROS_ERROR_STREAM ( \"controlLoop exception:\" << e . what ()); } } int main ( int argc , char ** argv ) { ros :: init ( argc , argv , \"my_node\" ); ros :: NodeHandle nh , private_nh ( \"~\" ); try { double control_frequency ; private_nh . param < double > ( \"control_frequency\" , control_frequency , 50.0 ); PCANLoop loop ; ros :: CallbackQueue queue ; ros :: AsyncSpinner spinner ( 1 , & queue ); ros :: TimerOptions control_timer ( ros :: Duration ( 1 / control_frequency ), boost :: bind ( controlLoop , boost :: ref ( loop )), & queue ); ros :: Timer control_loop = nh . createTimer ( control_timer ); spinner . start (); // Process remainder of ROS callbacks separately, mainly ControlManager related ros :: spin (); } catch ( std :: exception & e ) { ROS_ERROR_STREAM ( \"exception:\" << e . what ()); } return 0 ; } We will explain the code later. We need to describe the new node and its dependency in CMakeLists.txt and package.xml . Now open and edit the src\\my_pkg\\CMakeLists.txt file under the workspace. src\\my_pkg\\CMakeLists.txt Below is an example to describe a new node in CMake . ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages find_package ( catkin REQUIRED COMPONENTS roscpp ) ... ########### ## Build ## ########### ## Specify additional locations of header files ## Your package locations should be listed before other locations include_directories ( ${ catkin_INCLUDE_DIRS } ${ pcan_INCLUDE_DIRS } ) ## Declare a C++ executable ## With catkin_make all packages are built within a single CMake context ## The recommended prefix ensures that target names across packages don't collide add_executable ( ${ PROJECT_NAME } _node src/my_pkg_node.cpp ) ## Rename C++ executable without prefix ## The above recommended prefix causes long target names, the following renames the ## target back to the shorter version for ease of user use ## e.g. \"rosrun someones_pkg node\" instead of \"rosrun someones_pkg someones_pkg_node\" set_target_properties ( ${ PROJECT_NAME } _node PROPERTIES OUTPUT_NAME node PREFIX \"\" ) ## Add cmake target dependencies of the executable ## same as for the library above add_dependencies ( ${ PROJECT_NAME } _node ${ ${PROJECT_NAME } _EXPORTED_TARGETS} ${ catkin_EXPORTED_TARGETS } ) ## Specify libraries to link a library or executable target against target_link_libraries ( ${ PROJECT_NAME } _node ${ catkin_LIBRARIES } ${ pcan_LIBRARIES } ) ############# ## Install ## ############# # all install targets should use catkin DESTINATION variables # See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html ## Mark executables for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html install ( TARGETS ${ PROJECT_NAME } _node RUNTIME DESTINATION ${ CATKIN_PACKAGE_BIN_DESTINATION } ) src\\my_pkg\\package.xml Make sure roscpp in the <depend> list. <?xml version=\"1.0\"?> <package format= \"2\" > <name> my_pkg </name> ... <depend> roscpp </depend> ... </package>","title":"Step 3: Adding Simple CAN Read\\Write Loop"},{"location":"tutorials/peak/peak.html#simple-can-readwrite-loop","text":"In this example, we use Callback and Spinning from roscpp to set up a control loop running at 50Hz. In the callback, we read all the messages from the PCAN message queue and send a empty message to the CAN Bus. Depending on your CAN devices, you may need to add more protocol-specific implementation on top of the basic I/O.","title":"Simple CAN Read/Write Loop"},{"location":"tutorials/peak/peak.html#step-4-building-the-workspace","text":"Now we have all the code in place. Let's rebuild the workspace again to ensure everything built. : : Build the workspace c : \\can_ws > catkin_make install : : Add the install space into the current environment. c : \\can_ws > install\\setup.bat","title":"Step 4: Building the Workspace"},{"location":"tutorials/peak/peak.html#step-5-running-the-ros-application","text":"Before we launch the application, we need to make sure rosmaster is up and running. Start another ROS command prompt and run roscore . Now we are ready to run this application. c : \\can_ws > rosrun my_pkg node","title":"Step 5: Running the ROS Application"},{"location":"tutorials/peak/peak.html#summary","text":"In this tutorial, we walk through the steps of integrate PCAN-Basic library into your ROS package, how to consume it by an simple CAN read/write loop application. You are encouraged to proceed on the official PCAN-Basic documentation to learn more.","title":"Summary"},{"location":"tutorials/sick_s300/getting_started.html","text":"SICK S300 Safety Laser Scanner In this post, I will show you how to get started with SICK S300 Safety Laser Scanner in a ROS workspace. I will begin with an empty workspace, add required ROS packages, define and run an exmaple ROS application, and check laser scan in the ROS visualization tools. In this tutorial, I will be using cob_sick_s300 , a community ROS package, to drive SICK S300 to get the laser scan messages into ROS topics. For more information, see http://wiki.ros.org/cob_sick_s300 . Prerequisite You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have a SICK S300 Safety Laser Scanner commissioned to operate and connected to your host machine over a serial port. This tutorial applies to: S300 Standard S300 Advanced S300 Professional S300 Expert Step 1: Clone the Driver Package Firstly, you will need a catkin workspace to contain the driver package. Let's assume you are working on a empty workspace under c:\\s300_ws and now you need to clone the driver package and its dependencies into the source folder: : : change the directory to the source subfolder. c : \\s300_ws > cd src : : checkout the driver package code. c : \\s300_ws\\src > git clone https://github.com/ms-iot/cob_sick_s300 c : \\s300_ws\\src > git clone https://github.com/wjwwood/serial Step 2: Create your owned Package Now you have the required packages in your workspace. By ROS convention, it is common to manage the peripheral nodes in ROS launch files. However, since we begin this tutorial with an empty workspace, let's create a new package so we can add the ROS launch files later. : : change the directory to the source subfolder. c : \\s300_ws > cd src : : create your owned package c : \\s300_ws\\src > catkin_create_pkg my_pkg Step 3: Build the Workspace Let's build the workspace to produce the executables and binaries. And remember to run setup.bat to add the development space into the current environment. : : Build the workspace c : \\s300_ws > catkin_make : : Add the development space into the current environment. c : \\s300_ws > devel\\setup.bat Step 4: Write a ROS Launch file running Laser Scanner node At this moment, you are ready to add new ROS launch file for the new package. Let's add a new one called my_pkg.launch : : : Change the directory to new package c : \\s300_ws > roscd my_pkg : : Create the ROS launch file C : \\workspace\\s300_ws\\src\\my_pkg > mkdir launch && notepad launch\\my_pkg.launch Once the notepad gets launched, copy and paste the following text into the new file, save it, and close the notepad: <?xml version=\"1.0\"?> <launch> <!-- start laser driver --> <node name= \"laser_front\" pkg= \"cob_sick_s300\" type= \"cob_sick_s300\" respawn= \"false\" output= \"screen\" > <rosparam subst_value= \"true\" > port: COM1 baud: 115200 scan_duration: 0.025 #no info about that in SICK-docu, but 0.025 is believable and looks good in rviz scan_cycle_time: 0.040 #SICK-docu says S300 scans every 40ms inverted: true scan_id: 7 frame_id: /base_laser_link scan_intervals: [[-1.3526, 1.361357]] #[rad] these intervals are included to the scan </rosparam> </node> <!-- start ROS visualization tools --> <node name= \"rqt_gui\" pkg= \"rqt_gui\" type= \"rqt_gui\" /> <node name= \"rviz\" pkg= \"rviz\" type= \"rviz\" /> </launch> Before we move forward, let's take a look some important parameters to accommodate your environment: port should be pointed to where the SICK S300 connnected to your host machine. baud should be the baudrate configured by the SICK S300 . Step 5: Start to Run ROS application After everything is correctly configured, you are ready to run it. : : Run the ROS launch file c : \\s300_ws > roslaunch my_pkg my_pkg.launch A few moments later, you will see rqt and rviz tools running. On the rqt , you can turn on the real-time monitoring on the topic /laser_front/scan . And on the rviz , you can add built-in LaserScan display by topic and visualize /laser_front/scan in the 3D view port. Summary Now you have an initial bring-up for SICK S300 Safety Laser Scanner . You may need to tweak other parameters to reflect the settings of your laser scanner. For more information, visit http://wiki.ros.org/cob_sick_s300 for the complete guidance.","title":"SICK S300"},{"location":"tutorials/sick_s300/getting_started.html#sick-s300-safety-laser-scanner","text":"In this post, I will show you how to get started with SICK S300 Safety Laser Scanner in a ROS workspace. I will begin with an empty workspace, add required ROS packages, define and run an exmaple ROS application, and check laser scan in the ROS visualization tools. In this tutorial, I will be using cob_sick_s300 , a community ROS package, to drive SICK S300 to get the laser scan messages into ROS topics. For more information, see http://wiki.ros.org/cob_sick_s300 .","title":"SICK S300 Safety Laser Scanner"},{"location":"tutorials/sick_s300/getting_started.html#prerequisite","text":"You have a machine with Windows 10 installed. You have ROS Melodic Desktop Full installed. You have a SICK S300 Safety Laser Scanner commissioned to operate and connected to your host machine over a serial port. This tutorial applies to: S300 Standard S300 Advanced S300 Professional S300 Expert","title":"Prerequisite"},{"location":"tutorials/sick_s300/getting_started.html#step-1-clone-the-driver-package","text":"Firstly, you will need a catkin workspace to contain the driver package. Let's assume you are working on a empty workspace under c:\\s300_ws and now you need to clone the driver package and its dependencies into the source folder: : : change the directory to the source subfolder. c : \\s300_ws > cd src : : checkout the driver package code. c : \\s300_ws\\src > git clone https://github.com/ms-iot/cob_sick_s300 c : \\s300_ws\\src > git clone https://github.com/wjwwood/serial","title":"Step 1: Clone the Driver Package"},{"location":"tutorials/sick_s300/getting_started.html#step-2-create-your-owned-package","text":"Now you have the required packages in your workspace. By ROS convention, it is common to manage the peripheral nodes in ROS launch files. However, since we begin this tutorial with an empty workspace, let's create a new package so we can add the ROS launch files later. : : change the directory to the source subfolder. c : \\s300_ws > cd src : : create your owned package c : \\s300_ws\\src > catkin_create_pkg my_pkg","title":"Step 2: Create your owned Package"},{"location":"tutorials/sick_s300/getting_started.html#step-3-build-the-workspace","text":"Let's build the workspace to produce the executables and binaries. And remember to run setup.bat to add the development space into the current environment. : : Build the workspace c : \\s300_ws > catkin_make : : Add the development space into the current environment. c : \\s300_ws > devel\\setup.bat","title":"Step 3: Build the Workspace"},{"location":"tutorials/sick_s300/getting_started.html#step-4-write-a-ros-launch-file-running-laser-scanner-node","text":"At this moment, you are ready to add new ROS launch file for the new package. Let's add a new one called my_pkg.launch : : : Change the directory to new package c : \\s300_ws > roscd my_pkg : : Create the ROS launch file C : \\workspace\\s300_ws\\src\\my_pkg > mkdir launch && notepad launch\\my_pkg.launch Once the notepad gets launched, copy and paste the following text into the new file, save it, and close the notepad: <?xml version=\"1.0\"?> <launch> <!-- start laser driver --> <node name= \"laser_front\" pkg= \"cob_sick_s300\" type= \"cob_sick_s300\" respawn= \"false\" output= \"screen\" > <rosparam subst_value= \"true\" > port: COM1 baud: 115200 scan_duration: 0.025 #no info about that in SICK-docu, but 0.025 is believable and looks good in rviz scan_cycle_time: 0.040 #SICK-docu says S300 scans every 40ms inverted: true scan_id: 7 frame_id: /base_laser_link scan_intervals: [[-1.3526, 1.361357]] #[rad] these intervals are included to the scan </rosparam> </node> <!-- start ROS visualization tools --> <node name= \"rqt_gui\" pkg= \"rqt_gui\" type= \"rqt_gui\" /> <node name= \"rviz\" pkg= \"rviz\" type= \"rviz\" /> </launch> Before we move forward, let's take a look some important parameters to accommodate your environment: port should be pointed to where the SICK S300 connnected to your host machine. baud should be the baudrate configured by the SICK S300 .","title":"Step 4: Write a ROS Launch file running Laser Scanner node"},{"location":"tutorials/sick_s300/getting_started.html#step-5-start-to-run-ros-application","text":"After everything is correctly configured, you are ready to run it. : : Run the ROS launch file c : \\s300_ws > roslaunch my_pkg my_pkg.launch A few moments later, you will see rqt and rviz tools running. On the rqt , you can turn on the real-time monitoring on the topic /laser_front/scan . And on the rviz , you can add built-in LaserScan display by topic and visualize /laser_front/scan in the 3D view port.","title":"Step 5: Start to Run ROS application"},{"location":"tutorials/sick_s300/getting_started.html#summary","text":"Now you have an initial bring-up for SICK S300 Safety Laser Scanner . You may need to tweak other parameters to reflect the settings of your laser scanner. For more information, visit http://wiki.ros.org/cob_sick_s300 for the complete guidance.","title":"Summary"}]}